{"/docs/core/TypedBody":{"title":"TypedBody","data":{"":"","outline#Outline":"export function TypedBody(): ParameterDecorator;\nRequest body decorator 20,000x faster, even easy to use.@TypedBody() is a decorator function parsing application/json typed request body, and validates the request body value type through typia.assert<T>() function. If the request body is not following the promised type, 400 bad request error would be thrown.It is almost same with original @Body() function of NestJS, however, 20,000x faster.Also, @TypedBody() is much more easier to use than class-validator, because it can use pure TypeScript type. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle.IUpdate interface type. You may understand what it means.","how-to-use#How to use":"import { tags } from \"typia\";\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\nid: string & tags.Format<\"uuid\">;\ncreated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\ntitle: string & tags.MinLength<3> & tags.MaxLength<50>;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\nname: null | (string & tags.MinLength<1> & tags.MaxLength<255>)\nextension: null | (string & tags.MinLength<1> & tags.MaxLength<8>)\nurl: string & tags.Format<\"url\">;\n}\n\n\n\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Post()\npublic async store(\n@TypedBody() input: IBbsArticle.IStore\n): Promise<IBbsArticle> {\nreturn {\n...input,\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\n}\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nstore(input) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn Object.assign(Object.assign({}, input), { id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\", created_at: \"2023-04-23T12:04:54.168Z\" });\n});\n}\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate([\ncore_1.TypedRoute.Post({ type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $io0 = input => \"string\" === typeof input.id && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) && (\"string\" === typeof input.created_at && !isNaN(new Date(input.created_at).getTime())) && (\"string\" === typeof input.title && (3 <= input.title.length && input.title.length <= 50)) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length && input.name.length <= 255)) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length && input.extension.length <= 8)) && (\"string\" === typeof input.url && /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.TypedRoute.Post.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string & Format<\\\"uuid\\\">\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"(string & Format<\\\"uuid\\\">)\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && (!isNaN(new Date(input.created_at).getTime()) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string & Format<\\\"date-time\\\">\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"(string & Format<\\\"date-time\\\">)\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MinLength<3>\",\nvalue: input.title\n})) && (input.title.length <= 50 || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MaxLength<50>\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"(string & MinLength<3> & MaxLength<50>)\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MinLength<1>\",\nvalue: input.name\n})) && (input.name.length <= 255 || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MaxLength<255>\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"((string & MinLength<1> & MaxLength<255>) | null)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MinLength<1>\",\nvalue: input.extension\n})) && (input.extension.length <= 8 || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MaxLength<8>\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string & Format<\\\"url\\\">\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"(string & Format<\\\"url\\\">)\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length && input.name.length <= 255)) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length && input.extension.length <= 8)) && (\"string\" === typeof input.url && /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));\nconst $string = core_1.TypedRoute.Post.string;\nconst $so0 = input => `{\"id\":${$string(input.id)},\"created_at\":${$string(input.created_at)},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${$string(input.url)}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); } }),\n__param(0, (0, core_1.TypedBody)({ type: \"assert\", assert: input => {\nconst __is = input => {\nconst $io0 = input => \"string\" === typeof input.title && (3 <= input.title.length && input.title.length <= 50) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length && input.name.length <= 255)) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length && input.extension.length <= 8)) && (\"string\" === typeof input.url && /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.TypedBody.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MinLength<3>\",\nvalue: input.title\n})) && (input.title.length <= 50 || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MaxLength<50>\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"(string & MinLength<3> & MaxLength<50>)\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MinLength<1>\",\nvalue: input.name\n})) && (input.name.length <= 255 || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MaxLength<255>\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"((string & MinLength<1> & MaxLength<255>) | null)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MinLength<1>\",\nvalue: input.extension\n})) && (input.extension.length <= 8 || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MaxLength<8>\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string & Format<\\\"url\\\">\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"(string & Format<\\\"url\\\">)\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle.IStore\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle.IStore\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n} })),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"store\", null);\nexports.BbsArticlesController = BbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\n\n\nJust call @TypedBody() function on the request body parameter, that's all.Nestia will analyze your type (IBbsArticle.IUpdate), and writes optimal code for the target type, in the compilation level. If you click the \"Complied JavaScript File\" tab of above, you can see the optimal validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedBody.","special-tags#Special Tags":"You can enhance validation logic, of @TypedBody(), through special tags.You know what? @TypedBody() utilizes typia.assert<T>() function for request body data validation, and the typia.assert<T>() function supports additional type checking logics through type and comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\nint32: number & tags.Type<\"int32\">;\nrange?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\nminLength: string & tags.MinLength<3>;\npattern: string & tags.Pattern<\"^[a-z]+$\">;\ndate: null | (string & tags.Format<\"date\">);\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\nuuids: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.int32 &&\nMath.floor(input.int32) === input.int32 &&\n-2147483648 <= input.int32 &&\ninput.int32 <= 2147483647 &&\n(undefined === input.range ||\n(\"number\" === typeof input.range &&\n19 < input.range &&\ninput.range <= 100)) &&\n\"string\" === typeof input.minLength &&\n3 <= input.minLength.length &&\n\"string\" === typeof input.pattern &&\n/^[a-z]+$/.test(input.pattern) &&\n(null === input.date ||\n(\"string\" === typeof input.date &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n\"string\" === typeof input.ip &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.ip,\n) ||\n/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\ninput.ip,\n)) &&\nArray.isArray(input.uuids) &&\n3 <= input.uuids.length &&\ninput.uuids.length <= 100 &&\ninput.uuids.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;","benchmark#Benchmark":"Super-fast and super-safe.Nestia utilizes typia, and NestJS uses class-validator. One thing amazing is, typia is maximum 20,000x faster than class-validator of NestJS. Color of class-transformer is skyblue, and can you find the skyblue color in the below benchmark graph? It may hard to find because class-validator is extremely slow.\nMeasured on Intel i5-1135g7, Surface Pro 8\nFurthermore, while other libraries can't validate complicate union types, typia can validate every TypeScript types. However, in the class-validator case, it always be failed when any type of complicate comes. I can't understand why NestJS has adopted such slow and unstable library.Moreover, only typia can utilize pure TypeScript type, without any extra schema definition. Beside, all of other libraries require extra and duplicated schema definition, different with pure TypeScript type. Nestia is using such wonderful, super-fast and super-fast typia library.\nTypeBox requires TypeBox schema\najv requires JSON schema definition\nio-ts requires io-ts schema\nzod requires zod schema\nclass-validator requires DTO class with decorator function calls\n\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/docs/core/TypedException":{"title":"TypedException","data":{"":"","outline#Outline":"export function TypedException<T extends object>(\nstatus: number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\",\ndescription?: string,\n): MethodDecorator;\nException decorator only for swagger documents.TypedException is a decorator function describing HTTP exception and its type which could be occured in a controller method. For reference, this decorator function does not affect to the method's behavior, but affects to the swagger documents generation, or SDK functions when propagation mode being used.","how-to-use#How to use":"import { Controller } from \"@nestjs/common\";\nimport typia, { TypeGuardError } from \"typia\";\n\nimport {\nTypedBody,\nTypedException,\nTypedParam,\nTypedRoute,\n} from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\nimport { IInternalServerError } from \"@api/lib/structures/IInternalServerError\";\nimport { INotFound } from \"@api/lib/structures/INotFound\";\nimport { IUnprocessibleEntity } from \"@api/lib/structures/IUnprocessibleEntity\";\n\n@Controller(\"exception\")\nexport class ExceptionController {\n@TypedRoute.Post(\":section/typed\")\n@TypedException<TypeGuardError>(400, \"invalid request\")\n@TypedException<INotFound>(404, \"unable to find the matched section\")\n@TypedException<IUnprocessibleEntity>(428)\n@TypedException<IInternalServerError>(\"5XX\", \"internal server error\")\npublic async typed(\n@TypedParam(\"section\") section: string,\n@TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nsection;\ninput;\nreturn typia.random<IBbsArticle>();\n}\n}\nJust call TypedException() function with target type and status code.If you want to add description, you can add it as second parameter.For reference, swagger allows to use special pattern like 2XX, 3XX, 4XX, 5XX for status code.","swagger-example#Swagger Example":"Here is an example of swagger documents utilizing the @TypedException() decorator.https://editor.swagger.io/?url=https%3A%2F%2Fraw.githubusercontent.com%2Fsamchon%2Fnestia%2Fmaster%2Ftest%2Ffeatures%2Fexception%2Fswagger.json"}},"/docs/core/TypedParam":{"title":"TypedParam","data":{"":"","outline#Outline":"export function TypedParam(name: string): ParameterDecorator;\nexport function TypedParam(\nname: string,\ntype: \"uuid\" | \"date\"\n): ParameterDecorator;\nType safe path parameter decorator.@TypedParam() is a decorator parsing path parameter.It's almost same with original @Param() function of NestJS, however, @TypedParam() is more type safe.As @TypedParam() can anlayze source code in the compilation level, it can specify parameter type by itself. Also, while NestJS cannot distinguish nullable type and consider every parameter value as a string type, @TypedParam() can do it. Furthermore, @TypedParam() can validate special types like \"uuid\" or \"date\".Let's read below example code, and see how @TypedParam() works.","how-to-use#How to use":"import { TypedParam } from \"@nestia/core\";\nimport { Controller, Get } from \"@nestjs/common\";\nimport { tags } from \"typia\";\n\n@Controller(\"parameters\")\nexport class ParametersController {\n@Get(\"uint32/:value\")\npublic async uint32(\n@TypedParam(\"value\") value: (number & tags.Type<\"uint32\">) | null,\n): Promise<(number & tags.Type<\"uint32\">) | null> {\nreturn value;\n}\n\n@Get(\"string/:value\")\npublic async string(\n@TypedParam(\"value\") value: string,\n): Promise<string> {\nreturn value;\n}\n\n@Get(\"uuid/:value\")\npublic async uuid(\n@TypedParam(\"value\") value: string & tags.Format<\"uuid\">,\n): Promise<string> {\nreturn value;\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParametersController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet ParametersController = class ParametersController {\nuint32(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\nstring(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\nuuid(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\n};\nexports.ParametersController = ParametersController;\n__decorate([\n(0, common_1.Get)(\"uint32/:value\"),\n__param(0, (0, core_1.TypedParam)(\"value\", {\nname: \"((number & Type<\\\"uint32\\\">) | null)\",\nis: input => {\nreturn null === input || \"number\" === typeof input && (Math.floor(input) === input && 0 <= input && input <= 4294967295);\n},\ncast: str => \"null\" === str ? null : Number(str)\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"uint32\", null);\n__decorate([\n(0, common_1.Get)(\"string/:value\"),\n__param(0, (0, core_1.TypedParam)(\"value\", {\nname: \"string\",\nis: input => {\nreturn \"string\" === typeof input;\n},\ncast: str => str\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [String]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"string\", null);\n__decorate([\n(0, common_1.Get)(\"uuid/:value\"),\n__param(0, (0, core_1.TypedParam)(\"value\", {\nname: \"(string & Format<\\\"uuid\\\">)\",\nis: input => {\nreturn \"string\" === typeof input && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input);\n},\ncast: str => str\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"uuid\", null);\nexports.ParametersController = ParametersController = __decorate([\n(0, common_1.Controller)(\"parameters\")\n], ParametersController);\n\n\nJust call @TypedParam() function on the path paremeter, that's all.If you want to special parameter type like \"uint32\" or \"uuid\", utilize type tags of typia.When wrong typed value comes, 400 bad request error would be thrown.","restriction#Restriction":"@TypedParam() allows only atomic type.\nboolean\nnumber\nstring\nbigint\n\nAlso, @TypedParam() allows nullable like number | null, but undefindable type is not.\nnumber | null is allowed\nstring | undefined is prohibited\n\nIf you violate above condition, and try to declare object or union type, compilation error would be occured:\nError on nestia.core.TypedParam(): only atomic type is allowed"}},"/docs/core/TypedHeaders":{"title":"TypedHeaders","data":{"":"","outline#Outline":"export function TypedHeaders(): ParameterDecorator;\nRequest headers decorator, type safe.@TypedHeaders() is a decorator function parsing request headers to a typed object. It validates the request header values through typia.assert<T>(). If the request header values are invalid, it will throw 400 bad request exception.It is almost same with original @Headers() of NestJS, but much type safe.","how-to-use#How to use":"export interface IHeaders {\n\"x-category\": \"x\" | \"y\" | \"z\";\n\"x-memo\"?: string;\n\"x-name\"?: string;\n\"x-values\": number[];\n\"x-flags\": boolean[];\n\"X-Descriptions\": string[]; // ALLOW UPPER-CASE\n}\n\n\n\nimport { Controller } from \"@nestjs/common\";\n\nimport core from \"@nestia/core\";\n\nimport { IHeaders } from \"@api/lib/structures/IHeaders\";\n\n@Controller(\"headers/:section\")\nexport class HeadersController {\n/**\n* Emplace headers.\n*\n* @param headers Headers for authentication\n* @param section Target section code\n* @returns Store article\n*\n* @author Samchon\n*/\n@core.TypedRoute.Patch()\npublic emplace(\n@core.TypedHeaders() headers: IHeaders,\n@core.TypedParam(\"section\", \"string\") section: string,\n): void {\nheaders;\nsection;\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\nreturn (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HeadersController = void 0;\nconst common_1 = require(\"@nestjs/common\");\nconst core_1 = __importDefault(require(\"@nestia/core\"));\nlet HeadersController = exports.HeadersController = class HeadersController {\n/**\n* Emplace headers.\n*\n* @param headers Headers for authentication\n* @param section Target section code\n* @returns Store article\n*\n* @author Samchon\n*/\nemplace(headers, section) {\nheaders;\nsection;\n}\n};\n__decorate([\n(0, common_1.Get)(),\n__param(0, core_1.default.TypedHeaders(input => {\nconst $number = core_1.default.TypedHeaders.number;\nconst $boolean = core_1.default.TypedHeaders.boolean;\nconst $string = core_1.default.TypedHeaders.string;\nconst output = {\n\"x-category\": input[\"x-category\"],\n\"x-memo\": input[\"x-memo\"],\n\"x-name\": input[\"x-name\"],\n\"x-values\": input[\"x-values\"]?.split(\", \")?.map($number),\n\"x-flags\": input[\"x-flags\"]?.split(\", \")?.map($boolean),\n\"X-Descriptions\": input[\"x-descriptions\"]?.split(\", \")?.map($string),\n// AUTOMATIC UPPER-CASE CONVERTING\n};\nreturn (input => {\nconst __is = input => {\nconst $io0 = input => (\"x\" === input[\"x-category\"] || \"y\" === input[\"x-category\"] || \"z\" === input[\"x-category\"]) && (undefined === input[\"x-memo\"] || \"string\" === typeof input[\"x-memo\"]) && (undefined === input[\"x-name\"] || \"string\" === typeof input[\"x-name\"]) && (Array.isArray(input[\"x-values\"]) && input[\"x-values\"].every(elem => \"number\" === typeof elem && Number.isFinite(elem))) && (Array.isArray(input[\"x-flags\"]) && input[\"x-flags\"].every(elem => \"boolean\" === typeof elem)) && (Array.isArray(input[\"X-Descriptions\"]) && input[\"X-Descriptions\"].every(elem => \"string\" === typeof elem));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.default.TypedHeaders.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"x\" === input[\"x-category\"] || \"y\" === input[\"x-category\"] || \"z\" === input[\"x-category\"] || $guard(_exceptionable, {\npath: _path + \"[\\\"x-category\\\"]\",\nexpected: \"(\\\"x\\\" | \\\"y\\\" | \\\"z\\\")\",\nvalue: input[\"x-category\"]\n})) && (undefined === input[\"x-memo\"] || \"string\" === typeof input[\"x-memo\"] || $guard(_exceptionable, {\npath: _path + \"[\\\"x-memo\\\"]\",\nexpected: \"(string | undefined)\",\nvalue: input[\"x-memo\"]\n})) && (undefined === input[\"x-name\"] || \"string\" === typeof input[\"x-name\"] || $guard(_exceptionable, {\npath: _path + \"[\\\"x-name\\\"]\",\nexpected: \"(string | undefined)\",\nvalue: input[\"x-name\"]\n})) && ((Array.isArray(input[\"x-values\"]) || $guard(_exceptionable, {\npath: _path + \"[\\\"x-values\\\"]\",\nexpected: \"Array<number>\",\nvalue: input[\"x-values\"]\n})) && input[\"x-values\"].every((elem, _index1) => \"number\" === typeof elem && Number.isFinite(elem) || $guard(_exceptionable, {\npath: _path + \"[\\\"x-values\\\"][\" + _index1 + \"]\",\nexpected: \"number\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \"[\\\"x-values\\\"]\",\nexpected: \"Array<number>\",\nvalue: input[\"x-values\"]\n})) && ((Array.isArray(input[\"x-flags\"]) || $guard(_exceptionable, {\npath: _path + \"[\\\"x-flags\\\"]\",\nexpected: \"Array<boolean>\",\nvalue: input[\"x-flags\"]\n})) && input[\"x-flags\"].every((elem, _index2) => \"boolean\" === typeof elem || $guard(_exceptionable, {\npath: _path + \"[\\\"x-flags\\\"][\" + _index2 + \"]\",\nexpected: \"boolean\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \"[\\\"x-flags\\\"]\",\nexpected: \"Array<boolean>\",\nvalue: input[\"x-flags\"]\n})) && ((Array.isArray(input[\"X-Descriptions\"]) || $guard(_exceptionable, {\npath: _path + \"[\\\"X-Descriptions\\\"]\",\nexpected: \"Array<string>\",\nvalue: input[\"X-Descriptions\"]\n})) && input[\"X-Descriptions\"].every((elem, _index3) => \"string\" === typeof elem || $guard(_exceptionable, {\npath: _path + \"[\\\"X-Descriptions\\\"][\" + _index3 + \"]\",\nexpected: \"string\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \"[\\\"X-Descriptions\\\"]\",\nexpected: \"Array<string>\",\nvalue: input[\"X-Descriptions\"]\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IHeaders\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IHeaders\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n})(output);\n})),\n__param(1, core_1.default.TypedParam(\"section\", \"string\", false)),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object, String]),\n__metadata(\"design:returntype\", void 0)\n], HeadersController.prototype, \"emplace\", null);\nexports.HeadersController = HeadersController = __decorate([\n(0, common_1.Controller)(\"headers/:section\")\n], HeadersController);\n\n\nJust call @TypedHeaders() function on the request headers parameter, that's all.Nestia will analyze your type (IHeaders), and write optimal conversion and validation code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal code.Also, as you can see from the \"Compiled JavaScript File\", when upper case alphabet is used in the header key name like IHeaders[\"X-Descriptions\"], @TypedHeaders() would automatically convert to the upper case alphabet key named property from lower case key named property of raw data.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedHeaders\nBesides, the original @Headers() decorator of NestJS does not support such automatic upper case conversion. When you've define upper-cased property name in DTO, undefined value always be assigned, even if you've sent upper-cased property in the client side.","special-tags#Special Tags":"You can enhance validation logic, of @TypedHeaders(), through comment tags.You know what? @TypedHeaders() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\nint32: number & tags.Type<\"int32\">;\nrange?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\nminLength: string & tags.MinLength<3>;\npattern: string & tags.Pattern<\"^[a-z]+$\">;\ndate: null | (string & tags.Format<\"date\">);\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\nuuids: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.int32 &&\nMath.floor(input.int32) === input.int32 &&\n-2147483648 <= input.int32 &&\ninput.int32 <= 2147483647 &&\n(undefined === input.range ||\n(\"number\" === typeof input.range &&\n19 < input.range &&\ninput.range <= 100)) &&\n\"string\" === typeof input.minLength &&\n3 <= input.minLength.length &&\n\"string\" === typeof input.pattern &&\n/^[a-z]+$/.test(input.pattern) &&\n(null === input.date ||\n(\"string\" === typeof input.date &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n\"string\" === typeof input.ip &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.ip,\n) ||\n/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\ninput.ip,\n)) &&\nArray.isArray(input.uuids) &&\n3 <= input.uuids.length &&\ninput.uuids.length <= 100 &&\ninput.uuids.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedHeaders(), you've to follow such restrictions.At first, type of @TypedHeaders() must be a pure object type. It does not allow union type. Also, nullable types are not allowed, either. Note that, request headers type must be a sole object type without any extra definition. Of course, the word object does not contain array type.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\n\nAt last, HTTP headers has special restriction on value types for specific key names. For example, Set-Cookie must be Array type, and Authorization must be an atomic type like string. Therefore, @TypedHeaders() also restricts the value type of specific key names, and it is described in below.\nOnly array type allowed:\nset-cookie\n\n\nOnly atomic type allowed:\nage\nauthorization\ncontent-length\ncontent-type\netag\nexpires\nfrom\nhost\nif-modified-since\nif-unmodified-since\nlast-modified\nlocation\nmax-forwards\nproxy-authorization\nreferer\nretry-after\nserver\nuser-agent\n\n\n\n\nexport interface SomeHeadersDto {\n//----\n// ATOMIC TYPES\n//----\n// ALLOWED\nboolean: boolean;\nnumber: number;\nstring: string;\nbigint: bigint;\noptional_number?: number;\nnullable_string: string | null;\nliteral_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n// NOT ALLOWED\nmixed_union: string | number | boolean;\nmixed_literal: \"A\" | \"B\" | 3;\n\n//----\n// ARRAY TYPES\n//----\n// ALLOWED\nnullable_element_array: (string | null)[];\nstring_array: string[];\nnumber_array: number[];\nliteral_union_array: (\"A\" | \"B\" | \"C\")[];\nliteral_tuple: [\"A\", \"B\", \"C\"];\n\n// NOT ALLOWED\noptional_element_array: (string | undefined)[];\noptional_array: string[] | undefined;\nnullable_array: string[] | null;\nunion_atomic_array: (string | number)[];\nmixed_literal_array: (\"A\", \"B\", 3)[];\nmixed_tuple: [\"A\", \"B\", 3];\n\n//----\n// SPECIAL CASES\n//----\n// MUST BE ARRAY\n\"Set-Cookie\": string[];\n\n// MUST BE ATOMIC\nAccept: string;\nAuthorization: string;\n\n// NOT ALLOWED - MUST BE ATOMIC\nreferer: string[];\nage: number[];\n}"}},"/docs/core/TypedQuery":{"title":"TypedQuery","data":{"":"","outline#Outline":"export function TypedQuery(): ParameterDecorator;\nType safe URL query decorator.@TypedQuery() is a decorator parsing URL query.It's almost same with original @Query() function of NestJS, but @TypedQuery() is more stable and general.While NestJS does not support query type validation, @TypedQuery() validates the request query type and throws 400 bad request error when mismatched. Also, while NestJS does not support property type (@Query() only supports string typed properties), @TypedQuery() can define variable property types like bigint, number or boolean.\nWhat the query parameter is?This is the query parameter!\nname=Samchon&age=20&sex=male","how-to-use#How to use":"import { tags } from \"typia\";\n\nexport namespace IBbsArticle {\nexport interface ISummary {\nid: string & tags.Format<\"uuid\">;\nwriter: string;\ntitle: string & tags.MinLength<3> & tags.MaxLength<50>;\ncreated_at: string & tags.Format<\"date-time\">;\n}\n}\n\n\n\nimport { tags } from \"typia\";\n\nexport interface IPage<T> {\ndata: T[];\npagination: IPage.IPagination;\n}\nexport namespace IPage {\n/**\n* Page request data\n*/\nexport interface IRequest {\npage?: number & tags.Type<\"uint32\">;\nlimit?: number & tags.Type<\"uint32\">;\n}\n\n/**\n* Page information.\n*/\nexport interface IPagination {\ncurrent: number & tags.Type<\"uint32\">;\nlimit: number & tags.Type<\"uint32\">;\nrecords: number & tags.Type<\"uint32\">;\npages: number & tags.Type<\"uint32\">;\n}\n}\n\n\n\nimport { TypedQuery, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\nimport { IPage } from \"./IPage\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Get()\npublic async index(\n@TypedQuery() query: IPage.IRequest\n): Promise<IPage<IBbsArticle.ISummary>> {\nreturn {\npagination: {\ncurrent: query.page ?? 1,\nlimit: query.limit ?? 100,\nrecords: 0,\npages: 0,\n},\ndata: [],\n};\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nindex(query) {\nvar _a, _b;\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn {\npagination: {\ncurrent: (_a = query.page) !== null && _a !== void 0 ? _a : 1,\nlimit: (_b = query.limit) !== null && _b !== void 0 ? _b : 100,\nrecords: 0,\npages: 0,\n},\ndata: [],\n};\n});\n}\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate([\ncore_1.TypedRoute.Get({ type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $io0 = input => Array.isArray(input.data) && input.data.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)) && (\"object\" === typeof input.pagination && null !== input.pagination && (\"number\" === typeof input.pagination.current && (Math.floor(input.pagination.current) === input.pagination.current && 0 <= input.pagination.current && input.pagination.current <= 4294967295) && (\"number\" === typeof input.pagination.limit && (Math.floor(input.pagination.limit) === input.pagination.limit && 0 <= input.pagination.limit && input.pagination.limit <= 4294967295)) && (\"number\" === typeof input.pagination.records && (Math.floor(input.pagination.records) === input.pagination.records && 0 <= input.pagination.records && input.pagination.records <= 4294967295)) && (\"number\" === typeof input.pagination.pages && (Math.floor(input.pagination.pages) === input.pagination.pages && 0 <= input.pagination.pages && input.pagination.pages <= 4294967295))));\nconst $io1 = input => \"string\" === typeof input.id && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) && \"string\" === typeof input.writer && (\"string\" === typeof input.title && (3 <= input.title.length && input.title.length <= 50)) && (\"string\" === typeof input.created_at && !isNaN(new Date(input.created_at).getTime()));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.TypedRoute.Get.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => ((Array.isArray(input.data) || $guard(_exceptionable, {\npath: _path + \".data\",\nexpected: \"Array<IBbsArticle.ISummary>\",\nvalue: input.data\n})) && input.data.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".data[\" + _index1 + \"]\",\nexpected: \"IBbsArticle.ISummary\",\nvalue: elem\n})) && $ao1(elem, _path + \".data[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".data[\" + _index1 + \"]\",\nexpected: \"IBbsArticle.ISummary\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".data\",\nexpected: \"Array<IBbsArticle.ISummary>\",\nvalue: input.data\n})) && ((\"object\" === typeof input.pagination && null !== input.pagination || $guard(_exceptionable, {\npath: _path + \".pagination\",\nexpected: \"IPage.IPagination\",\nvalue: input.pagination\n})) && $ao2(input.pagination, _path + \".pagination\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".pagination\",\nexpected: \"IPage.IPagination\",\nvalue: input.pagination\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string & Format<\\\"uuid\\\">\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"(string & Format<\\\"uuid\\\">)\",\nvalue: input.id\n})) && (\"string\" === typeof input.writer || $guard(_exceptionable, {\npath: _path + \".writer\",\nexpected: \"string\",\nvalue: input.writer\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MinLength<3>\",\nvalue: input.title\n})) && (input.title.length <= 50 || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MaxLength<50>\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"(string & MinLength<3> & MaxLength<50>)\",\nvalue: input.title\n})) && (\"string\" === typeof input.created_at && (!isNaN(new Date(input.created_at).getTime()) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string & Format<\\\"date-time\\\">\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"(string & Format<\\\"date-time\\\">)\",\nvalue: input.created_at\n}));\nconst $ao2 = (input, _path, _exceptionable = true) => (\"number\" === typeof input.current && (Math.floor(input.current) === input.current && 0 <= input.current && input.current <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".current\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.current\n})) || $guard(_exceptionable, {\npath: _path + \".current\",\nexpected: \"(number & Type<\\\"uint32\\\">)\",\nvalue: input.current\n})) && (\"number\" === typeof input.limit && (Math.floor(input.limit) === input.limit && 0 <= input.limit && input.limit <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"(number & Type<\\\"uint32\\\">)\",\nvalue: input.limit\n})) && (\"number\" === typeof input.records && (Math.floor(input.records) === input.records && 0 <= input.records && input.records <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".records\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.records\n})) || $guard(_exceptionable, {\npath: _path + \".records\",\nexpected: \"(number & Type<\\\"uint32\\\">)\",\nvalue: input.records\n})) && (\"number\" === typeof input.pages && (Math.floor(input.pages) === input.pages && 0 <= input.pages && input.pages <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".pages\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.pages\n})) || $guard(_exceptionable, {\npath: _path + \".pages\",\nexpected: \"(number & Type<\\\"uint32\\\">)\",\nvalue: input.pages\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage<IBbsArticle.ISummary>\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage<IBbsArticle.ISummary>\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $io1 = input => \"string\" === typeof input.id && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) && \"string\" === typeof input.writer && (\"string\" === typeof input.title && (3 <= input.title.length && input.title.length <= 50)) && (\"string\" === typeof input.created_at && !isNaN(new Date(input.created_at).getTime()));\nconst $io2 = input => \"number\" === typeof input.current && (Math.floor(input.current) === input.current && 0 <= input.current && input.current <= 4294967295) && (\"number\" === typeof input.limit && (Math.floor(input.limit) === input.limit && 0 <= input.limit && input.limit <= 4294967295)) && (\"number\" === typeof input.records && (Math.floor(input.records) === input.records && 0 <= input.records && input.records <= 4294967295)) && (\"number\" === typeof input.pages && (Math.floor(input.pages) === input.pages && 0 <= input.pages && input.pages <= 4294967295));\nconst $string = core_1.TypedRoute.Get.string;\nconst $so0 = input => `{\"data\":${`[${input.data.map(elem => `{\"id\":${$string(elem.id)},\"writer\":${$string(elem.writer)},\"title\":${$string(elem.title)},\"created_at\":${$string(elem.created_at)}}`).join(\",\")}]`},\"pagination\":${`{\"current\":${input.pagination.current},\"limit\":${input.pagination.limit},\"records\":${input.pagination.records},\"pages\":${input.pagination.pages}}`}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); } }),\n__param(0, (0, core_1.TypedQuery)(input => {\nvar _a, _b;\nconst $number = core_1.TypedQuery.number;\nconst output = {\npage: (_a = $number(input.get(\"page\"))) !== null && _a !== void 0 ? _a : undefined,\nlimit: (_b = $number(input.get(\"limit\"))) !== null && _b !== void 0 ? _b : undefined\n};\nreturn (input => {\nconst __is = input => {\nconst $io0 = input => (undefined === input.page || \"number\" === typeof input.page && (Math.floor(input.page) === input.page && 0 <= input.page && input.page <= 4294967295)) && (undefined === input.limit || \"number\" === typeof input.limit && (Math.floor(input.limit) === input.limit && 0 <= input.limit && input.limit <= 4294967295));\nreturn \"object\" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.TypedQuery.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (undefined === input.page || \"number\" === typeof input.page && (Math.floor(input.page) === input.page && 0 <= input.page && input.page <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".page\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.page\n})) || $guard(_exceptionable, {\npath: _path + \".page\",\nexpected: \"((number & Type<\\\"uint32\\\">) | undefined)\",\nvalue: input.page\n})) && (undefined === input.limit || \"number\" === typeof input.limit && (Math.floor(input.limit) === input.limit && 0 <= input.limit && input.limit <= 4294967295 || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number & Type<\\\"uint32\\\">\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"((number & Type<\\\"uint32\\\">) | undefined)\",\nvalue: input.limit\n}));\nreturn (\"object\" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage.IRequest\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage.IRequest\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n})(output);\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"index\", null);\nexports.BbsArticlesController = BbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\n\n\nJust call @TypedQuery() function on the query parameter, that's all.Nestia will analyze your type (IPage.IRequest), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript\" file tab of above and fine enhanced lines by blue lines, you can see the optimal parsing and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedQuery.","special-tags#Special Tags":"You can enhance validation logic, of @TypedQuery(), through comment tags.You know what? @TypedQuery() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\nint32: number & tags.Type<\"int32\">;\nrange?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\nminLength: string & tags.MinLength<3>;\npattern: string & tags.Pattern<\"^[a-z]+$\">;\ndate: null | (string & tags.Format<\"date\">);\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\nuuids: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.int32 &&\nMath.floor(input.int32) === input.int32 &&\n-2147483648 <= input.int32 &&\ninput.int32 <= 2147483647 &&\n(undefined === input.range ||\n(\"number\" === typeof input.range &&\n19 < input.range &&\ninput.range <= 100)) &&\n\"string\" === typeof input.minLength &&\n3 <= input.minLength.length &&\n\"string\" === typeof input.pattern &&\n/^[a-z]+$/.test(input.pattern) &&\n(null === input.date ||\n(\"string\" === typeof input.date &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n\"string\" === typeof input.ip &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.ip,\n) ||\n/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\ninput.ip,\n)) &&\nArray.isArray(input.uuids) &&\n3 <= input.uuids.length &&\ninput.uuids.length <= 100 &&\ninput.uuids.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;","restriction#Restriction":"When using @TypedQuery(), you've to follow such restrction.At first, type of @TypedQuery() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\n\n\nexport interface SomeQueryDto {\n//----\n// ATOMIC TYPES\n//----\n// ALLOWED\nboolean: boolean;\nnumber: number;\nstring: string;\nbigint: bigint;\noptional_number?: number;\nnullable_string: string | null;\nliteral_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n// NOT ALLOWED\nmixed_union: string | number | boolean;\nmixed_literal: \"A\" | \"B\" | 3;\n\n//----\n// ARRAY TYPES\n//----\n// ALLOWED\nnullable_element_array: (string | null)[];\nstring_array: string[];\nnumber_array: number[];\nliteral_union_array: (\"A\" | \"B\" | \"C\")[];\nliteral_tuple: [\"A\", \"B\", \"C\"];\n\n// NOT ALLOWED\noptional_element_array: (string | undefined)[];\noptional_array: string[] | undefined;\nnullable_array: string[] | null;\nunion_atomic_array: (string | number)[];\nmixed_literal_array: (\"A\", \"B\", 3)[];\nmixed_tuple: [\"A\", \"B\", 3];\n}"}},"/docs":{"title":"Index","data":{"":"","outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: super-fast decorators\n@nestia/sdk:\nSwagger generator evolved than ever\nSDK library generator for clients\nMockup Simulator for client developers\nAutomatic E2E test functions generator\n\n\n@nestia/migrate: migration from Swagger to NestJS\nnestia: just CLI (command line interface) tool\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nEnhance performance 30x up\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\n\n\n\nSoftware Development Kit\nSDK is a collection of fetch functions with type definitions like tRPC\nMockup simulator means embedded backend simulator in SDK\nsimilar with msw, but fully automated\n\n\n\n\n\n\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/core/TypedRoute":{"title":"TypedRoute","data":{"":"","outline#Outline":"export namespace TypedRoute {\nexport function Get(path?: string): MethodDecorator;\nexport function Post(path?: string): MethodDecorator;\nexport function Patch(path?: string): MethodDecorator;\nexport function Put(path?: string): MethodDecorator;\nexport function Delete(path?: string): MethodDecorator;\n}\nRoute decorators 200x faster, even type safe and easy to use.TypedRoute is a namespaced module containing router decorators utilizing typia.assertStringify<T>() function. Those decorators are almost same with original NestJS, but TypedRoute can boost up JSON serialization speed maximum 200x times faster than class-transformer, therefore much faster than original NestJS.Furthermore, as TypedRoute utilizes typia.assertStringify<T>() function, it is even type safe. The typia.assertStringify<T>() function validates response data type, via typia.assert<T>() function, before JSON serialization. Therefore, if you try to return wrong typed value, it would be blocked with 500 internal server error.Moreover, TypedRoute is much easier than class-transformer, because it just needs only pure TypeScript type definition. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle interface type. You may understand what it means.","how-to-use#How to use":"import { tags } from \"typia\";\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\nid: string & tags.Format<\"uuid\">;\ncreated_at: string & tags.Format<\"date-time\">;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\ntitle: string & tags.MinLength<3> & tags.MaxLength<50>;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\nname: null | (string & tags.MinLength<1> & tags.MaxLength<255>)\nextension: null | (string & tags.MinLength<1> & tags.MaxLength<8>)\nurl: string & tags.Format<\"url\">;\n}\n\n\n\nimport { TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n/**\n* Get random article for testing.\n*/\n@TypedRoute.Get(\"random\")\npublic async random(): Promise<IBbsArticle> {\nreturn {\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ntitle: \"Hello nestia users\",\nbody: \"Just use `TypedRoute.Get()` function like this\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\nfiles: [],\n};\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n/**\n* Get random article for testing.\n*/\nrandom() {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn {\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ntitle: \"Hello nestia users\",\nbody: \"Just use `TypedRoute.Get()` function like this\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\nfiles: [],\n};\n});\n}\n};\nexports.BbsArticlesController = BbsArticlesController;\n__decorate([\ncore_1.TypedRoute.Get(\"random\", { type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $io0 = input => \"string\" === typeof input.id && /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) && (\"string\" === typeof input.created_at && !isNaN(new Date(input.created_at).getTime())) && (\"string\" === typeof input.title && (3 <= input.title.length && input.title.length <= 50)) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length && input.name.length <= 255)) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length && input.extension.length <= 8)) && (\"string\" === typeof input.url && /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $guard = core_1.TypedRoute.Get.guard;\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string & Format<\\\"uuid\\\">\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"(string & Format<\\\"uuid\\\">)\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && (!isNaN(new Date(input.created_at).getTime()) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string & Format<\\\"date-time\\\">\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"(string & Format<\\\"date-time\\\">)\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MinLength<3>\",\nvalue: input.title\n})) && (input.title.length <= 50 || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string & MaxLength<50>\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"(string & MinLength<3> & MaxLength<50>)\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable) || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n}));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MinLength<1>\",\nvalue: input.name\n})) && (input.name.length <= 255 || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string & MaxLength<255>\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"((string & MinLength<1> & MaxLength<255>) | null)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MinLength<1>\",\nvalue: input.extension\n})) && (input.extension.length <= 8 || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string & MaxLength<8>\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"((string & MinLength<1> & MaxLength<8>) | null)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && (/^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string & Format<\\\"url\\\">\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"(string & Format<\\\"url\\\">)\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true) || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n});\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && (1 <= input.name.length && input.name.length <= 255)) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length && input.extension.length <= 8)) && (\"string\" === typeof input.url && /^[a-zA-Z0-9]+:\\/\\/(?:www.)?[-a-zA-Z0-9@:%._+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()@:%_+.~#?&/=]*)$/.test(input.url));\nconst $string = core_1.TypedRoute.Get.string;\nconst $so0 = input => `{\"id\":${$string(input.id)},\"created_at\":${$string(input.created_at)},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${$string(input.url)}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); } }),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", []),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"random\", null);\nexports.BbsArticlesController = BbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\n\n\nJust call @TypedRoute.${method}() function on the target method, that's all.Nestia will analyze your type (IBbsArticle), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal validation and JSON serialization code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of TypedRoute.","special-tags#Special Tags":"You can enhance validation logic, of TypedRoute, through comment tags.You know what? @TypedRoute.${method}() functions are using typia.assertStringify<T>() function, that is combined with typia.assert<T>() and typia.stringify<T>() functions. It is the secret of @TypedRoute.${method}() functions, which can validates response body data type before JSON serialization, and throws 500 internal server error when the data type is not matched.Also, as typia.assert<T>() function can utililze comment tags for additional validation, TypedRoute also can utillze them, too. For reference, \"Type Tag\" means a intersection type with atomic type and special tag type of typia like number & tags.Type<\"uint32\">, and \"Comment Tag\" means a comment starting from @ symbol following @${name} ${value} format.With those type and comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such type and comment tags, in a few minutes.\ntypia > Validators > Custom Tags\nOutline\nType Tags\nComment Tags\nCustomization\n\n\n\n\n\n\nimport typia, { tags } from \"typia\";\n\nexport const checkSpecialTag = typia.createIs<SpecialTag>();\n\ninterface SpecialTag {\nint32: number & tags.Type<\"int32\">;\nrange?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\nminLength: string & tags.MinLength<3>;\npattern: string & tags.Pattern<\"^[a-z]+$\">;\ndate: null | (string & tags.Format<\"date\">);\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\nuuids: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n}\n\n\n\n\"use strict\";\nvar __importDefault =\n(this && this.__importDefault) ||\nfunction (mod) {\nreturn mod && mod.__esModule ? mod : { default: mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkSpecialTag = void 0;\nconst typia_1 = __importDefault(require(\"typia\"));\nconst checkSpecialTag = (input) => {\nconst $io0 = (input) =>\n\"number\" === typeof input.int32 &&\nMath.floor(input.int32) === input.int32 &&\n-2147483648 <= input.int32 &&\ninput.int32 <= 2147483647 &&\n(undefined === input.range ||\n(\"number\" === typeof input.range &&\n19 < input.range &&\ninput.range <= 100)) &&\n\"string\" === typeof input.minLength &&\n3 <= input.minLength.length &&\n\"string\" === typeof input.pattern &&\n/^[a-z]+$/.test(input.pattern) &&\n(null === input.date ||\n(\"string\" === typeof input.date &&\n/^(d{4})-(d{2})-(d{2})$/.test(input.date))) &&\n\"string\" === typeof input.ip &&\n(/^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(\ninput.ip,\n) ||\n/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/.test(\ninput.ip,\n)) &&\nArray.isArray(input.uuids) &&\n3 <= input.uuids.length &&\ninput.uuids.length <= 100 &&\ninput.uuids.every(\n(elem) =>\n\"string\" === typeof elem &&\n/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i.test(\nelem,\n),\n);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nexports.checkSpecialTag = checkSpecialTag;","benchmark#Benchmark":"","json#JSON":"Comparing JSON serialization speed, typia is maximum 200x faster than class-transformer.For reference, Nestia is using typia, and NestJS is using class-transformer. The other one fast-json-stringify is made and used by fastify (do not mean NestJS fastify mode, but mean pure fastify library. NestJS fastify mode still utilizes class-transformer), and it requires JSON schema definition.From above benchmark graph, you can see that class-transformer is extremely slower than others, even including built-in JSON.stringify() function. I can't understand why NestJS has adopted such slow and difficult library. The other fast-json-stringify is enough faster, but it needs extra schema definition like class-validator, therefore not easy to use.\ntypia needs only pure TypeScript type.\nclass-transformer requires DTO class with decorator function calls.\nfast-json-stringify requires JSON schema definition.\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8","server#Server":"Looking at above benchmark, someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/migrate":{"title":"Swagger to NestJS","data":{"":"","outline#Outline":"Supports OpenAPI v3.0 only.\n\n# SETUP GLOBALLY\nnpm install -g @nestia/migrate\n\n# DO MIGRATE\nnpx @nestia/migrate swagger.json output_directory\n@nestia/migrate converts swagger.json file to a NestJS project.When you run npx @nestia/migrate swagger.json <output> command, @nestia/migrate will analyze your swagger.json file, and generate a NestJS project into the <output> direcory. If you're considering to migrate your backend project to NestJS, @nestia/migrate will be a good starting point.Also, @nestia/sdk can generate below things from NestJS project.It means that, with @nestia/migrate, you can generate SDK Library or Mockup Simulator from every backend projects. If you don't have plan to migrate to NestJS, but hope to take advantages of it, @nestia/migrate will be a good choice. Languages and frameworks, they're no longer matter in backend development. Let's enjoy the new world with @nestia/migrate.\nSDK (Software Development Kit)\nMockup Simulator\nAutomated e2e test functions\n\n\n\nLeft is NestJS code converted from @nestia/migrate\nRight is client side code utilizing SDK generated by @nestia/sdk","setup#Setup":"# SETUP GLOBALLY\nnpm install -g @nestia/migrate\n\n# DO MIGRATE\nnpx @nestia/migrate swagger.json output_directory\nAt first, install @nestia/migrate globally.After that, run npx @nestia/migrate <input> <output> command. The first <input> argument must be target swagger.json file, and the second <output> argument must be output directory to be a NestJS project. When you run that command, @nestia/migrate will analyze your swagger.json file, and generate a NestJS project into the <output> direcory.By the way, @nestia/migrate supports only OpenAPI v3.0 specification. If you have a swagger.json file with OpenAPI v1 or v2 specification, you can't convert it to a NestJS project. In that case, rebuild the swagger.json file from your backend project, specifying OpenAPI v3.0 specification.","generated-nestjs-project#Generated NestJS Project":"{\n\"openapi\": \"3.0.1\",\n\"paths\": {\n\"/body\": {\n\"post\": {\n\"tags\": [],\n\"parameters\": [],\n\"requestBody\": {\n\"description\": \"\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n}\n}\n},\n\"required\": true\n},\n\"responses\": {\n\"201\": {\n\"description\": \"\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle\"\n}\n}\n}\n}\n}\n}\n}\n}\n}\n\n\n\nimport core from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"../../api/structures/IBbsArticle\";\n\n@Controller(\"body\")\nexport class BodyController {\n@core.TypedRoute.Post()\npublic async post(\n@core.TypedBody() body: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nbody;\nreturn typia.random<IBbsArticle>();\n}\n}\n\n\n\n/**\n* @packageDocumentation\n* @module api.functional.body\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\n//================================================================\nimport { Fetcher } from \"@nestia/fetcher\";\nimport type { IConnection } from \"@nestia/fetcher\";\nimport typia from \"typia\";\n\nimport { NestiaSimulator } from \"./../../utils/NestiaSimulator\";\nimport type { IBbsArticle } from \"./../../structures/IBbsArticle\";\n\n/**\n* @controller BodyController.post()\n* @path POST /body\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function post(\nconnection: IConnection,\nbody: IBbsArticle.IStore,\n): Promise<post.Output> {\nreturn !!connection.simulate\n? post.simulate(\nconnection,\nbody,\n)\n: Fetcher.fetch(\nconnection,\npost.ENCRYPTED,\npost.METHOD,\npost.path(),\nbody,\n);\n}\nexport namespace post {\nexport type Input = IBbsArticle.IStore;\nexport type Output = IBbsArticle;\n\nexport const METHOD = \"POST\" as const;\nexport const PATH: string = \"/body\";\nexport const ENCRYPTED: Fetcher.IEncrypted = {\nrequest: false,\nresponse: false,\n};\n\nexport const path = (): string => {\nreturn `/body`;\n}\nexport const random = (g?: Partial<typia.IRandomGenerator>): Output =>\ntypia.random<Output>(g);\nexport const simulate = async (\nconnection: IConnection,\nbody: post.Input,\n): Promise<Output> => {\nconst assert = NestiaSimulator.assert({\nmethod: METHOD,\nhost: connection.host,\npath: path()\n});\nassert.body(() => typia.assert(body));\nreturn random(\ntypeof connection.simulate === 'object' &&\nconnection.simulate !== null\n? connection.simulate\n: undefined\n);\n}\n}\n\n\nNewly generated NestJS project by @nestia/migrate would form like above.At first, every controllers would be generated following URL path hierarchy. Also, typia.random<T>() function would be utilized in every route methods to generate random data following specific response DTO type. SDK library and Mockup simulator also utilize the typia.random<T>() function too.As you can see from above example case, @nestia/migrate perfectly revives every DTO types and route methods, but it doesn't revive business logics. It means that, you have to implement business logics by yourself. Of course, it's not a matter if you're utilizing @nestia/migrate not for real NestJS migration, but for generating SDK library and Mockup simulator only.","nestia-editor#Nestia Editor":"I'm making a new library named @nestia/editor.It's a type of evolved swagger-ui, embedding TypeScript Editor, @nestia/migrate and @nestia/sdk.By embedding TypeScript Editor in swagger-ui, you can take advatanges of TypeScript compiler like type hints and auto-completions. Also, if you turn on simulation mode, @nestia/editor will utilize embeded Mockup Simulator of @nestia/sdk, instead of sending request to the real backend server.Of course, as @nestia/editor includes @nestia/migrate, you can build and download SDK library and Mockup Simulator in the website.Look forward to it, I'll show you a new world."}},"/playground":{"title":"Index","data":{"":""}},"/":{"title":"Index","data":{"":"","outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: super-fast decorators\n@nestia/sdk:\nSwagger generator evolved than ever\nSDK library generator for clients\nMockup Simulator for client developers\nAutomatic E2E test functions generator\n\n\n@nestia/migrate: migration from Swagger to NestJS\nnestia: just CLI (command line interface) tool\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nEnhance performance 30x up\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\n\n\n\nSoftware Development Kit\nSDK is a collection of fetch functions with type definitions like tRPC\nMockup simulator means embedded backend simulator in SDK\nsimilar with msw, but fully automated\n\n\n\n\n\n\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/sdk/simulator":{"title":"Mockup Simulator","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\nsimulate: true, // supports simulation mode\ninput: \"src/controllers\",\noutput: \"src/api\",\ne2e: \"test\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nnpx nestia sdk\n\n\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller BbsArticlesController.update()\n* @path PUT /bbs/:section/articles/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function update(\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<update.Output> {\nreturn !!connection.simulate\n? update.simulate(\nconnection,\nsection,\nid,\ninput,\n)\n: PlainFetcher.fetch(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...update.METADATA,\npath: update.path(section, id),\n} as const,\ninput,\n);\n}\nexport namespace update {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METADATA = {\nmethod: \"PUT\",\npath: \"/bbs/articles/:section/:id\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string, id: string & Format<\"uuid\">): string => {\nreturn `/bbs/${encodeURIComponent(section ?? \"null\")}/articles/${encodeURIComponent(id ?? \"null\")}`;\n};\n\nexport const random = (g?: Partial<typia.IRandomGenerator>): Output =>\ntypia.random<Output>(g);\n\nexport const simulate = async (\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<Output> => {\nconst assert = NestiaSimulator.assert({\nmethod: METHOD,\nhost: connection.host,\npath: path(section, id)\n});\nassert.param(\"section\")(\"string\")(() => typia.assert(section));\nassert.param(\"id\")(\"uuid\")(() => typia.assert(id));\nassert.body(() => typia.assert(input));\nreturn random(\ntypeof connection.simulate === 'object'\n&& connection.simulate !== null\n? connection.simulate\n: undefined\n);\n};\n}\n\n\nNestia SDK library supports Mockup simulator.When generating SDK library, if you configure simulate property of nestia.config.file to be true, newly generated SDK library will support mockup simulation mode for frontend developers. With the mockup simulator, frontend developers can simulate NestJS backend server with internal mock functions, instead of connecting to the real backend server.Therefore, with the mockup simulator, frontend development can be started even when the backend server is not ready yet. Mockup simulator of Nestia SDK will replace the real backend server, validating request data and returning mockup data as response.Within framework of backend developers, they also do not need to be suffered from the mock-up data composition. Also, as nestia can automatically generate e2e test functions, backend developers can concentrated only on the business logic.","confguration#Confguration":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\nsimulate: true, // supports simulation mode\ninput: \"src/controllers\",\noutput: \"src/api\",\ne2e: \"test\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport type { ISwagger } from \"./structures/ISwagger\";\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Allow simulation mode.\n*\n* If you configure this property to be `true`, the SDK library would be contain\n* simulation mode. In the simulation mode, the SDK library would not communicate\n* with the real backend server, but just returns random mock-up data\n* with requestion data validation.\n*\n* For reference, random mock-up data would be generated by `typia.random<T>()`\n* function.\n*\n* @default false\n*/\nsimulate?: boolean;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Whether to use propagation mode or not.\n*\n* If being configured, interaction functions of the SDK library would\n* perform the propagation mode. The propagation mode means that never\n* throwing exception even when status code is not 200 (or 201), but just\n* returning the {@link IPropagation} typed instance, which can specify its body\n* type through discriminated union determined by status code.\n*\n* @default false\n*/\npropagate?: boolean;\n\n/**\n* Whether to clone DTO structures or not.\n*\n* If being configured, all of DTOs used in the backend server would be cloned\n* into the `structures` directory, and the SDK library would be refer to the\n* cloned DTOs instead of the original.\n*\n* @default false\n*/\nclone?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n\n/**\n* Location of `tsconfig.json` file.\n*\n* If be configured, target file will replace the `tsconfig.json` file.\n*\n* @default tsconfig.json\n*/\nproject?: string;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwagger.IServer[];\n\n/**\n* Security schemes.\n*\n* When generating `swagger.json` file through `nestia`, if your controllers or\n* theirs methods have a security key which is not enrolled in here property,\n* it would be an error.\n*/\nsecurity?: Record<string, ISwaggerSecurityScheme>;\n\n/**\n* Decompose query DTO.\n*\n* If you configure this property to be `true`, the query DTO would be decomposed\n* into individual query parameters per each property.\n*\n* @default false\n*/\ndecompose?: boolean;\n\noperationId?(props: {\nclass: string;\nfunction: string;\nmethod: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\npath: string;\n}): string;\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties. Also, if you've decided to support mockup simulator for frontend developers, I recommend you to configure two properties more, for automatic e2e functions generation and SDK library distribution.\nEssential\ninput: Path of controller files\noutput: Path of output directory for SDK library\nsimulate: Whether to support simulator or not\n\n\nRecommended\ne2e: Path of output directory for E2E test functions\ndistribute: Target directory for SDK library distribution\n\n\n\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be generated into the $config.output directory, with simulation mode supporting. If you want to generate e2e functions automatically, run npx nestia e2e command after.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\noutput: \"src/api\",\nsimulate: true,\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\noutput: \"src/api\",\nsimulate: true,\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\noutput: \"src/api\",\nsimulate: true,\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;","code-analysis#Code Analysis":"/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller BbsArticlesController.update()\n* @path PUT /bbs/:section/articles/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function update(\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<update.Output> {\nreturn !!connection.simulate\n? update.simulate(\nconnection,\nsection,\nid,\ninput,\n)\n: PlainFetcher.fetch(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...update.METADATA,\npath: update.path(section, id),\n} as const,\ninput,\n);\n}\nexport namespace update {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METADATA = {\nmethod: \"PUT\",\npath: \"/bbs/articles/:section/:id\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string, id: string & Format<\"uuid\">): string => {\nreturn `/bbs/${encodeURIComponent(section ?? \"null\")}/articles/${encodeURIComponent(id ?? \"null\")}`;\n};\n\nexport const random = (g?: Partial<typia.IRandomGenerator>): Output =>\ntypia.random<Output>(g);\n\nexport const simulate = async (\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<Output> => {\nconst assert = NestiaSimulator.assert({\nmethod: METHOD,\nhost: connection.host,\npath: path(section, id)\n});\nassert.param(\"section\")(() => typia.assert(section));\nassert.param(\"id\")(() => typia.assert(id));\nassert.body(() => typia.assert(input));\nreturn random(\ntypeof connection.simulate === 'object'\n&& connection.simulate !== null\n? connection.simulate\n: undefined\n);\n};\n}\n\n\n\nimport { HttpError } from \"@nestia/fetcher\";\n\nimport typia from \"typia\";\n\nexport namespace NestiaSimulator {\nexport interface IProps {\nhost: string;\npath: string;\nmethod: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\ncontentType: string;\n}\n\nexport const assert = (props: IProps) => {\nreturn {\nparam: param(props),\nquery: query(props),\nbody: body(props),\n};\n};\nconst param =\n(props: IProps) =>\n(name: string) =>\n<T>(task: () => T): void => {\nvalidate(\n(exp) => `URL parameter \"${name}\" is not ${exp.expected} type.`,\n)(props)(task);\n};\n\nconst query =\n(props: IProps) =>\n<T>(task: () => T): void =>\nvalidate(\n() =>\n\"Request query parameters are not following the promised type.\",\n)(props)(task);\n\nconst body =\n(props: IProps) =>\n<T>(task: () => T): void =>\nvalidate(() => \"Request body is not following the promised type.\")(\nprops,\n)(task);\n\nconst validate =\n(message: (exp: typia.TypeGuardError) => string, path?: string) =>\n(props: IProps) =>\n<T>(task: () => T): void => {\ntry {\ntask();\n} catch (exp) {\nif (typia.is<typia.TypeGuardError>(exp))\nthrow new HttpError(\nprops.method,\nprops.host + props.path,\n400,\n{\n\"Content-Type\": props.contentType,\n},\nJSON.stringify({\nmethod: exp.method,\npath: path ?? exp.path,\nexpected: exp.expected,\nvalue: exp.value,\nmessage: message(exp),\n}),\n);\nthrow exp;\n}\n};\n}\n\n\nLet's read generated SDK library code, and understand which features are supportedAt first, you can find that mock-up data is composed by typia.random<T>() function. Also, simulator function validates path parameters and request body data through typia.assert<T>() function. If the validation fails, 400 status error would be thrown.At last, if frontend developer turns off simulation mode by configuring IConnection.simulate value to be false, the SDK library stops NestJS backend server simulating, and just start communicating with the real backend server."}},"/docs/sdk/e2e":{"title":"E2e","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nnpx nestia e2e\n\n\nConfigure nestia.config.ts file and run npx nestia e2e command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate both SDK (Software Development Kit) library for client developers. Also, E2E test functions, utilizing the SDK library, will be automatically generated for correspnding to every API functions.Here is an example of generated E2E test functions:\nimport typia, { Primitive } from \"typia\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_body_store = async (\nconnection: api.IConnection\n): Promise<void> => {\nconst output = await api.functional.body.store(\nconnection,\ntypia.random<Primitive<IBbsArticle.IStore>>(),\n);\ntypia.assert(output);\n};\n\nLeft is server code, and right is e2e test code utilizing SDK library","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport type { ISwagger } from \"./structures/ISwagger\";\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Allow simulation mode.\n*\n* If you configure this property to be `true`, the SDK library would be contain\n* simulation mode. In the simulation mode, the SDK library would not communicate\n* with the real backend server, but just returns random mock-up data\n* with requestion data validation.\n*\n* For reference, random mock-up data would be generated by `typia.random<T>()`\n* function.\n*\n* @default false\n*/\nsimulate?: boolean;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Whether to use propagation mode or not.\n*\n* If being configured, interaction functions of the SDK library would\n* perform the propagation mode. The propagation mode means that never\n* throwing exception even when status code is not 200 (or 201), but just\n* returning the {@link IPropagation} typed instance, which can specify its body\n* type through discriminated union determined by status code.\n*\n* @default false\n*/\npropagate?: boolean;\n\n/**\n* Whether to clone DTO structures or not.\n*\n* If being configured, all of DTOs used in the backend server would be cloned\n* into the `structures` directory, and the SDK library would be refer to the\n* cloned DTOs instead of the original.\n*\n* @default false\n*/\nclone?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n\n/**\n* Location of `tsconfig.json` file.\n*\n* If be configured, target file will replace the `tsconfig.json` file.\n*\n* @default tsconfig.json\n*/\nproject?: string;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwagger.IServer[];\n\n/**\n* Security schemes.\n*\n* When generating `swagger.json` file through `nestia`, if your controllers or\n* theirs methods have a security key which is not enrolled in here property,\n* it would be an error.\n*/\nsecurity?: Record<string, ISwaggerSecurityScheme>;\n\n/**\n* Decompose query DTO.\n*\n* If you configure this property to be `true`, the query DTO would be decomposed\n* into individual query parameters per each property.\n*\n* @default false\n*/\ndecompose?: boolean;\n\noperationId?(props: {\nclass: string;\nfunction: string;\nmethod: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\npath: string;\n}): string;\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties:\ninput: Path of controller files\noutput: Path of output directory for SDK library\ne2e: Path of output directory for E2E test functions\n\nWhen you've completed above configuration, just run npx nestia e2e command. Then, SDK library would be generated into the $config.output directory, and E2E test functions would be generated into the $config.e2e directory, following your nestia.config.ts option.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;","customization#Customization":"import core from \"@nestia/core\";\nimport { DynamicExecutor } from \"@nestia/e2e\";\n\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nasync function main(): Promise<void> {\nconst server: INestApplication = await NestFactory.create(\nawait core.DynamicModule.mount({\n// follows your nestia.config.ts setting\ncontrollers: {\ninput: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\n}),\n);\nawait server.listen(37_000);\n\nconst report: DynamicExecutor.IReport = await DynamicExecutor.validate({\nprefix: \"test\",\nparameters: () => [\n{\nhost: \"http://127.0.0.1:37000\",\n},\n],\n})(`${__dirname}/features`);\nawait server.close();\n\nconst exceptions: Error[] = report.executions\n.filter((exec) => exec.error !== null)\n.map((exec) => exec.error!);\nif (exceptions.length === 0) {\nconsole.log(\"Success\");\nconsole.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n} else {\nfor (const exp of exceptions) console.log(exp);\nconsole.log(\"Failed\");\nconsole.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\nprocess.exit(-1);\n}\n}\nmain().catch((exp) => {\nconsole.log(exp);\nprocess.exit(-1);\n});\nNothing be specified, customize by yourself.When you generate e2e test functions through npx nestia e2e command, such index.ts file would be placed into the top level directory of test program. As you can see, the initial e2e test program only opens your NestJS backend server only with path of controllers with port number 37,000.However, it may not fully meet your requirements. For example, you may connect to a database server, and also need to configure DI (Dependency Injection) classes, too. You've to configure those things by yourself. @nestia/sdk can analyzes your backend server in the compilation level, but unable to reproduce such customizations.\n\n\nimport { Controller } from \"@nestjs/common\";\nimport typia, { tags } from \"typia\";\n\nimport core from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n/**\n* Store a new article.\n*\n* @param section Section code\n* @param input Content to store\n* @returns Newly archived article\n*/\n@core.TypedRoute.Post()\npublic async store(\n@core.TypedParam(\"section\") section: string,\n@core.TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\nsection,\n...input,\n};\n}\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*/\n@core.TypedRoute.Put(\":id\")\npublic async update(\n@core.TypedParam(\"section\") section: string,\n@core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n@core.TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\nid,\nsection,\n...input,\n};\n}\n}\n\n\n\n/**\n* @packageDocumentation\n* @module api.functional.bbs.articles\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\n//================================================================\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport type { Format } from \"typia/lib/tags/Format\";\n\nimport type { IBbsArticle } from \"../../../structures/IBbsArticle\";\n\n/**\n* Store a new article.\n*\n* @param section Section code\n* @param input Content to store\n* @returns Newly archived article\n*\n* @controller [object Object]\n* @path POST /bbs/articles/:section\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function store(\nconnection: IConnection,\nsection: string,\ninput: store.Input,\n): Promise<store.Output> {\nreturn PlainFetcher.fetch(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...store.METADATA,\npath: store.path(section),\n} as const,\ninput,\n);\n}\nexport namespace store {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METADATA = {\nmethod: \"POST\",\npath: \"/bbs/articles/:section\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string): string => {\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}`;\n}\n}\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller [object Object]\n* @path PUT /bbs/articles/:section/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function update(\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<update.Output> {\nreturn PlainFetcher.fetch(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...update.METADATA,\npath: update.path(section, id),\n} as const,\ninput,\n);\n}\nexport namespace update {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METADATA = {\nmethod: \"PUT\",\npath: \"/bbs/articles/:section/:id\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string, id: string & Format<\"uuid\">): string => {\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}/${encodeURIComponent(id ?? \"null\")}`;\n}\n}\n\n\n\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport type { Format } from \"typia/lib/tags/Format\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_bbs_articles_update = async (\nconnection: api.IConnection,\n): Promise<void> => {\nconst output = await api.functional.bbs.articles.update(\nconnection,\ntypia.random<string>(),\ntypia.random<string & Format<\"uuid\">>(),\ntypia.random<Primitive<IBbsArticle.IStore>>(),\n);\ntypia.assert(output);\n};\n\n\nYou also need to customize each e2e test functions.When you run npx nestia e2e command, every e2e functions would be placed into $config.e2e/features/api/automated directory. Also, automatically generated e2e test functions are composing parameters through typia.random<T>() function.If your NestJS backend server development has not been completed, and your API functions are in the mock-up level, such random parameter composition would not be problem. Otherwise your API functions are enoughly completed, such random parameter composition may occur logic error.Therefore, you also need to customize automatically generated e2e test functions. Move each e2e test files from the $config.e2e/features/api/automated directory to somewhere else, and customize those e2e test functions to be suitable for your domain logics."}},"/docs/pure":{"title":"Pure TypeScript","data":{"":"","outline#Outline":"nestia can use pure TypeScript type.You know what? NestJS needs triple duplicated DTO schema definitions. The 1st is defining TypeScript type, the 2nd and 3rd are calling decorator functions of class-validator and @nestjs/swagger. It's not only annoying, but also error-prone. If you take any mistake on the 2nd or 3rd, it can't be detected by TypeScript compiler. It will be detected only at runtime. Another words, it is not type safe.Besides, nestia needs only pure TypeScript type. You don't need to define any extra schema like class-validator or @nestjs/swagger. Just define pure TypeScript type only (especially recommend to use interface type), then nestia will do all the rest.","demonstration#Demonstration":"If you're confusing how DTO of NestJS and nestia are different, just see example codes below.At first, look at the first (Triple duplicated NestJS DTO) tab, and find the BbsArticle.files property, enhanced by blue coloured blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, nestia needs only one line. Click the second (Pure Nestia DTO) tab, and find the IAttachmentFile.files property. Only one line being used, and IBbsArticle and IAttachment types are not even class, but just interface types. Comparing it to the first tab, how do you feel? Isn't it more simple and readable?This is the power of nestia, with pure TypeScript type.\n\n\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport { ArrayNotEmpty, IsArray, IsObject, IsOptional, IsString, Match, MaxLength, Type, ValidateNested } from \"class-validator\";\n\nexport class BbsArticle {\n@ApiProperty({\nformat: \"uuid\",\n})\n@IsString()\nid!: string;\n\n// DUPLICATED SCHEMA DEFINITION\n// - duplicated function call + property type\n// - have to specify `isArray` and `nullable` props by yourself\n@ApiProperty({\ntype: () => AttachmentFile,\nnullable: true,\nisArray: true,\nminItems: 1,\ndescription: \"List of attached files.\",\n})\n@Type(() => AttachmentFile)\n@IsArray()\n@ArrayNotEmpty()\n@IsOptional()\n@IsObject({ each: true })\n@ValidateNested({ each: true })\nfiles!: AttachmentFile[] | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nminLength: 5,\nmaxLength: 100,\ndescription: \"Title of the article.\",\n})\n@IsOptional()\n@IsString()\ntitle!: string | null;\n\n@ApiProperty({\ndescription: \"Main content body of the article.\"\n})\n@IsString()\nbody!: string;\n\n@ApiProperty({\nformat: \"date-time\",\ndescription: \"Creation time of article\",\n})\n@IsString()\ncreated_at!: string;\n}\n\nexport class AttachmentFile {\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File name.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(255)\n@IsOptional()\n@IsString()\nname!: string | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File extension.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(8)\n@IsOptional()\n@IsString()\nextension!: string | null;\n\n@ApiProperty({\nformat: \"url\",\ndescription: \"URL of the file.\",\n})\n@IsString()\nurl!: string;\n}\n\n\n\nexport interface IBbsArticle {\n/**\n* Primary Key.\n*\n* @format uuid\n*/\nid: string;\n\n/**\n* List of attached files.\n*\n* @minItems 1\n*/\nfiles: IAttachmentFile[] | null;\n\n/**\n* Title of the article.\n*\n* @minLength 5\n* @maxLength 100\n*/\ntitle: string | null;\n\n/**\n* Main content body of the article.\n*/\nbody: string;\n\n/**\n* Creation time of article.\n*\n* @format date-time\n*/\ncreated_at: string;\n}\n\nexport interface IAttachmentFile {\n/**\n* File name.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* File extension.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* URL of the file.\n*\n* @format uri\n*/\nurl: string;\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can nestia validates types at runtime? How nestia builds swagger documents or SDK library with only these types? Are these things really possible without extra schema definition like class-validator or @nestjs/swagger?\"\nMy answer is: \"Yes, it is possible due to nestia analyzes your server code, and performs AOT compilation\".When compiling, nestia travels your NestJS server codes, and analyzes DTO definitions. And then, nestia writes optimal code to the compiled JavaScript file. In the @TypedBody() case, nestia transforms it to optimal validation code for the IBbsArticle.IStore type. Also, nestia transforms @TypedRoute.Post() function to optimal JSON serialization code for the IBbsArticle type.Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why nestia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why nestia is much easier, and futhermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\n\n\n\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format date-time\n*/\ncreated_at: string;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\n/**\n* @minLength 3\n* @maxLength 50\n*/\ntitle: string;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\n/**\n* @minLengt 1\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* @minLength 1\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* @format url\n*/\nurl: string;\n}\n\n\n\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Post() // 200x faster JSON serialization\npublic async store(\n// 20,000x faster validation\n@TypedBody() input: IBbsArticle.IStore\n): Promise<IBbsArticle> {\nreturn {\n...input,\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\n}\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nstore(input) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn Object.assign(Object.assign({}, input), { id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\", created_at: \"2023-04-23T12:04:54.168Z\" });\n});\n}\n};\n__decorate([\ncore_1.TypedRoute.Post({ type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at)) && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $string = core_1.TypedRoute.Post.string;\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nconst $so0 = input => `{\"id\":${\"\\\"\" + input.id + \"\\\"\"},\"created_at\":${\"\\\"\" + input.created_at + \"\\\"\"},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${\"\\\"\" + input.url + \"\\\"\"}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); }\n}),\n__param(0, (0, core_1.TypedBody)({\ntype: \"assert\",\nassert: input => {\nconst $guard = core_1.TypedBody.guard;\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst __is = input => {\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst $io0 = input => \"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle.IStore\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"store\", null);\nBbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\nexports.BbsArticlesController = BbsArticlesController;\n\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/sdk/sdk":{"title":"SDK Library","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nnpx nestia sdk\n\n\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller BbsArticlesController.update()\n* @path PUT /bbs/:section/articles/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function update(\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<update.Output> {\nreturn PlainFetcher.fetch(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...update.METADATA,\npath: update.path(section, id),\n} as const,\ninput,\n);\n}\nexport namespace update {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METADATA = {\nmethod: \"PUT\",\npath: \"/bbs/articles/:section/:id\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string, id: string & Format<\"uuid\">): string => {\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}/${encodeURIComponent(id ?? \"null\")}`;\n}\n}\n\n\nCollection of fetch functions with type definitions.Configure nestia.config.ts file and run npx nestia sdk command. Then, @nestia/sdk will analyze your NestJS backend server code, and generate SDK (Software Development Kit) library. The newly generated SDK library would be composed with DTO and fetch functions with type definitions following your NestJS server.With the SDK library, you can easily develop e2e test program. Also, frontend developers can utilize the SDK library to interact with your NestJS backend server, much safely and conveniently. If you can't imagine how the SDK library works, then look at the gif image of below. Left side is the NestJS backend server program, and right side is the Frontend program interacting with your server.Isn't it look like much more convenient and safer than before when using Swagger Documents?\nLeft is NestJS server code, and right is client (frontend) code utilizing SDK","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport type { ISwagger } from \"./structures/ISwagger\";\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Allow simulation mode.\n*\n* If you configure this property to be `true`, the SDK library would be contain\n* simulation mode. In the simulation mode, the SDK library would not communicate\n* with the real backend server, but just returns random mock-up data\n* with requestion data validation.\n*\n* For reference, random mock-up data would be generated by `typia.random<T>()`\n* function.\n*\n* @default false\n*/\nsimulate?: boolean;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Whether to use propagation mode or not.\n*\n* If being configured, interaction functions of the SDK library would\n* perform the propagation mode. The propagation mode means that never\n* throwing exception even when status code is not 200 (or 201), but just\n* returning the {@link IPropagation} typed instance, which can specify its body\n* type through discriminated union determined by status code.\n*\n* @default false\n*/\npropagate?: boolean;\n\n/**\n* Whether to clone DTO structures or not.\n*\n* If being configured, all of DTOs used in the backend server would be cloned\n* into the `structures` directory, and the SDK library would be refer to the\n* cloned DTOs instead of the original.\n*\n* @default false\n*/\nclone?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n\n/**\n* Location of `tsconfig.json` file.\n*\n* If be configured, target file will replace the `tsconfig.json` file.\n*\n* @default tsconfig.json\n*/\nproject?: string;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwagger.IServer[];\n\n/**\n* Security schemes.\n*\n* When generating `swagger.json` file through `nestia`, if your controllers or\n* theirs methods have a security key which is not enrolled in here property,\n* it would be an error.\n*/\nsecurity?: Record<string, ISwaggerSecurityScheme>;\n\n/**\n* Decompose query DTO.\n*\n* If you configure this property to be `true`, the query DTO would be decomposed\n* into individual query parameters per each property.\n*\n* @default false\n*/\ndecompose?: boolean;\n\noperationId?(props: {\nclass: string;\nfunction: string;\nmethod: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\npath: string;\n}): string;\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Path of controller files\noutput: Path of output directory for SDK library\n\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be newly generated, and placed into the $config.output directory following your nestia.config.ts configuration.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\noutput: \"src/api\",\n};\nexport default config;","comment-tags#Comment Tags":"SDK library of @nestia/sdk supports special comment tags configuring client headers.\n@setHeader\n@assignHeaders\n\nAt first, @setHeader {accessor} configures only one header property. It reads special value of response body data with the accessor, and configures the special value to client header with last accessor key. In the below example case, key of authorization.token would be token, and key of authorization.timeout would be timeout.The other one @assignHeaders overwrites every property values to the client headers, with special instance of response body data with accessor. In the below example case, every properties in IShoppingCustomer.IActivated[\"authorization\"] would be assigned to the clinet headers.If you're confused, read example codes of below, clicking each tabs.\n\n\nimport { Controller } from \"@nestjs/common\";\n\n@Controller(\"shoppings/consumers/authenticate\")\nexport class ShoppingConsumerAuthenticateController {\n/**\n* @setHeader authorization.token token\n* @setHeader authorization.timeout timeout\n*/\n@TypedRoute.Post(\"join\")\npublic join(\n@TypedBody() input: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated>;\n\n/**\n* @assignHeaders authorization\n*/\n@TypedRoute.Post(\"login\")\npublic login(\n@TypedBody() inpu: IShoppingConsumer.ILogin\n): Promise<IShoppingConsumer.IActivated>;\n}\n\n\n\n/**\n* @packageDocumentation\n* @module api.functional.shoppings.consumers.authenticate\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\n//================================================================\nimport type { IConnection, Primitive } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\n\nimport type { IShoppingConsumer } from \"../../../../structures/IShoppingConsumer\";\n\nexport async function join(\nconnection: IConnection,\ninput: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated> {\nconst output: IShoppingConsumer.IActivated = await Fetcher.fetch(\nconnection,\njoin.ENCRYPTED,\njoin.METHOD,\njoin.path(),\ninput,\n);\n\n// configure header(s)\nconnection.headers ??= {};\nconnection.headers.token = output.authorization.token;\nconnection.headers.timeout = output.authorization.timeout;\n\nreturn output;\n}\nexport namespace join {\n...\n}\n\nexport async function login(\nconnection: IConnection,\ninput: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated> {\nconst output: IShoppingConsumer.IActivated = await Fetcher.fetch(\nconnection,\nlogin.ENCRYPTED,\nlogin.METHOD,\nlogin.path(),\ninput,\n);\n\n// configure header(s)\nconnection.headers ??= {};\nObject.assign(connection.headers, output.authorization);\n\nreturn output;\n}\nexport namespace login {\n...\n}","propagation-mode#Propagation Mode":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\npropagate: true,\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport { Primitive } from \"./Primitive\";\n\n/**\n* Propagation type.\n*\n* `IPropagation` is a type gathering all possible status codes and their body\n* data types as a discriminated union type. You can specify the status code and\n* its body data type just by using conditional statement like below.\n*\n* ```typescript\n* type Output = IPropagation<{\n*    200: ISeller.IAuthorized;\n*    400: TypeGuardError.IProps;\n* >};\n*\n* const output: Output = await sdk.sellers.authenticate.join(input);\n* if (output.success) {\n*     // automatically casted to \"ISeller.IAuthorized\" type\n*     const authorized: ISeller.IAuthorized = output.data;\n* } else if (output.status === 400) {\n*     // automatically casted to \"TypeGuardError.IProps\" type\n*     const error: TypeGuardError.IProps = output.data;\n* } else {\n*     // unknown type when out of pre-defined status codes\n*     const result: unknown = output.data;\n* }\n* ```\n*\n* For reference, this `IPropagation` type is utilized by SDK library generated by\n* `@nestia/sdk`, when you've configured {@link INestiaConfig.propagate} to be `true`.\n* In that case, SDK functions generated by `@nestia/sdk` no more returns response DTO\n* typed data directly, but returns this `IPropagation` typed object instead.\n*\n* @template StatusMap Map of status code and its body data type.\n* @template Success Default success status code.\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport type IPropagation<\nStatusMap extends {\n[P in IPropagation.Status]?: any;\n},\nSuccess extends number = 200 | 201,\n> =\n| {\n[P in keyof StatusMap]: IPropagation.IBranch<\nP extends Success ? true : false,\nP,\nStatusMap[P]\n>;\n}[keyof StatusMap]\n| IPropagation.IBranch<false, unknown, unknown>;\nexport namespace IPropagation {\n/**\n* Type of configurable status codes.\n*\n* The special characters like `2XX`, `3XX`, `4XX`, `5XX` are meaning the range\n* of status codes. If `5XX` is specified, it means the status code is in the\n* range of `500` to `599`.\n*/\nexport type Status = number | \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\";\n\n/**\n* Branch type of propagation.\n*\n* `IPropagation.IBranch` is a branch type composing `IPropagation` type,\n* which is gathering all possible status codes and their body data types\n* as a union type.\n*/\nexport interface IBranch<Success extends boolean, StatusValue, BodyData> {\nsuccess: Success;\nstatus: StatusValue extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"\n? StatusRange<StatusValue>\n: StatusValue extends number\n? StatusValue\n: never;\ndata: Primitive<BodyData>;\nheaders: Record<string, string | string[]>;\n}\n\n/**\n* Range of status codes by the first digit.\n*/\nexport type StatusRange<T extends \"2XX\" | \"3XX\" | \"4XX\" | \"5XX\"> =\nT extends 0\n? IntRange<200, 299>\n: T extends 3\n? IntRange<300, 399>\n: T extends 4\n? IntRange<400, 499>\n: IntRange<500, 599>;\n\ntype IntRange<F extends number, T extends number> = Exclude<\nEnumerate<T>,\nEnumerate<F>\n>;\n\ntype Enumerate<\nN extends number,\nAcc extends number[] = [],\n> = Acc[\"length\"] extends N\n? Acc[number]\n: Enumerate<N, [...Acc, Acc[\"length\"]]>;\n}\n\n\nReturns IPropagation typed instance instead of throwing exception.When you configure propagate property of nestia.config.ts file, all of SDK functions generated by @nestia/sdk will perform propagation mode. The propagation mode means that never throwing exception (HttpError) even when response status code is not (or 201), but just returning the IPropagation typed object, which can specify its body data type through discriminated union determined by status code.Looking at below code tabs one by one, then you may understand exactly, what the propagation mode is. As you can see from below example code, @TypedException() decorator function can be utilized to define the failure type with specific status code. Also, if returned status code is out of pre-defined, the IPropagation.data type would be automatically casted to unknown type.\n\n\nimport { Controller } from \"@nestjs/common\";\nimport typia, { tags } from \"typia\";\n\nimport core from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*/\n@core.TypedException<TypeGuardError.IProps>(400)\n@core.TypedRoute.Put(\":id\")\npublic async update(\n@core.TypedParam(\"section\") section: string,\n@core.TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n@core.TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\nid,\nsection,\n...input,\n};\n}\n}\n\n\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller BbsArticlesController.update()\n* @path PUT /bbs/:section/articles/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport async function update(\nconnection: IConnection,\nsection: string,\nid: string & Format<\"uuid\">,\ninput: update.Input,\n): Promise<update.Output> {\nreturn PlainFetcher.propagate(\n{\n...connection,\nheaders: {\n...(connection.headers ?? {}),\n\"Content-Type\": \"application/json\",\n},\n},\n{\n...update.METADATA,\npath: update.path(section, id),\n} as const,\ninput,\n);\n}\nexport namespace update {\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = IPropagation<{\n200: IBbsArticle;\n400: TypeGuardError.IProps;\n}, 200>;\n\nexport const METADATA = {\nmethod: \"PUT\",\npath: \"/bbs/articles/:section/:id\",\nrequest: {\ntype: \"application/json\",\nencrypted: false\n},\nresponse: {\ntype: \"application/json\",\nencrypted: false,\n},\nstatus: null,\n} as const;\n\nexport const path = (section: string, id: string & Format<\"uuid\">): string => {\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}/${encodeURIComponent(id ?? \"null\")}`;\n}\n}\n\n\n\nconst output = await api.functional.bbs.articles.update(section, id, input);\nif (output.success) {\n// automatically casted to \"IBbsArticle\" when status 200 (success)\nconst article: IBbsArticle = output.data;\n} else if (output.status === 400) {\n// casted to \"TypeGuardError.IProps\" when status 400\nconst error: TypeGuardError.IProps = output.data;\n} else {\n// casted to \"unknown\" when out of pre-defined status codes\nconst result: unknown = output.data;\n}","distribution#Distribution":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\nThe best to way to distributing SDK library is just publishing as an NPM module.Configure distribute property of nestia.config.ts file, and run npx nestia sdk command. After that, distribution environments would be automatically composed with SDK library generation. At last, move to the packages/api directory, and run npm run deploy command for publishing.From now on, client developers can use the SDK library just by using npm install command.\ncd packages/api\nnpm run deploy\nOf course, before publishing the NPM module, you've to customize some configurations like package name. Initial name of the distribution envirionments is @ORGANIZATION/PROJECT-api, but you must change the package name of yours, isn't it?Also, if your SDK library utilize special alias paths, you also need to customize tsconfig.json file, too. Reading below example package.json and tsconfig.json files generated by nestia, consider which features to customize.\n\n\n{\n\"name\": \"@ORGANIZATION/PROJECT-api\",\n\"version\": \"0.1.0\",\n\"description\": \"SDK library generated by Nestia\",\n\"main\": \"lib/index.js\",\n\"typings\": \"lib/index.d.ts\",\n\"scripts\": {\n\"build\": \"npm run build:sdk && npm run compile\",\n\"build:sdk\": \"rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api\",\n\"compile\": \"rimraf lib && tsc\",\n\"deploy\": \"npm run build && npm publish\"\n},\n\"repository\": {\n\"type\": \"git\",\n\"url\": \"https://github.com/samchon/nestia\"\n},\n\"author\": \"Jeongho Nam\",\n\"license\": \"MIT\",\n\"bugs\": {\n\"url\": \"https://github.com/samchon/nestia/issues\"\n},\n\"homepage\": \"https://nestia.io\",\n\"devDependencies\": {\n\"rimraf\": \"^5.0.0\",\n\"typescript\": \"^5.0.4\",\n\"ts-patch\": \"^3.0.2\"\n},\n\"dependencies\": {\n\"@nestia/fetcher\": \"^2.0.0\",\n\"typia:: \"^5.0.4\"\n},\n\"files\": [\n\"lib\",\n\"package.json\",\n\"README.md\"\n]\n}\n\n\n\n{\n\"compilerOptions\": {\n\"target\": \"ES5\",\n\"lib\": [\n\"DOM\",\n\"ES2015\"\n],\n\"module\": \"commonjs\",\n\"declaration\": true,\n\"sourceMap\": true,\n\"outDir\": \"./lib\",\n\"downlevelIteration\": true,\n\"newLine\": \"lf\",\n\"esModuleInterop\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"strict\": true,\n\"skipLibCheck\": true\n},\n\"include\": [\n\"../../src/api\"\n]\n}"}},"/docs/sdk/swagger":{"title":"Swagger Documents","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nnpx nestia swagger\n\n\nConfigure nestia.config.ts file and run npx nestia swagger command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate swagger.json file.","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport type { ISwagger } from \"./structures/ISwagger\";\nimport type { ISwaggerInfo } from \"./structures/ISwaggerInfo\";\nimport type { ISwaggerSecurityScheme } from \"./structures/ISwaggerSecurityScheme\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Allow simulation mode.\n*\n* If you configure this property to be `true`, the SDK library would be contain\n* simulation mode. In the simulation mode, the SDK library would not communicate\n* with the real backend server, but just returns random mock-up data\n* with requestion data validation.\n*\n* For reference, random mock-up data would be generated by `typia.random<T>()`\n* function.\n*\n* @default false\n*/\nsimulate?: boolean;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Whether to use propagation mode or not.\n*\n* If being configured, interaction functions of the SDK library would\n* perform the propagation mode. The propagation mode means that never\n* throwing exception even when status code is not 200 (or 201), but just\n* returning the {@link IPropagation} typed instance, which can specify its body\n* type through discriminated union determined by status code.\n*\n* @default false\n*/\npropagate?: boolean;\n\n/**\n* Whether to clone DTO structures or not.\n*\n* If being configured, all of DTOs used in the backend server would be cloned\n* into the `structures` directory, and the SDK library would be refer to the\n* cloned DTOs instead of the original.\n*\n* @default false\n*/\nclone?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n\n/**\n* Location of `tsconfig.json` file.\n*\n* If be configured, target file will replace the `tsconfig.json` file.\n*\n* @default tsconfig.json\n*/\nproject?: string;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwagger.IServer[];\n\n/**\n* Security schemes.\n*\n* When generating `swagger.json` file through `nestia`, if your controllers or\n* theirs methods have a security key which is not enrolled in here property,\n* it would be an error.\n*/\nsecurity?: Record<string, ISwaggerSecurityScheme>;\n\n/**\n* Decompose query DTO.\n*\n* If you configure this property to be `true`, the query DTO would be decomposed\n* into individual query parameters per each property.\n*\n* @default false\n*/\ndecompose?: boolean;\n\noperationId?(props: {\nclass: string;\nfunction: string;\nmethod: \"HEAD\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\";\npath: string;\n}): string;\n}\n}\n\n\n\n/**\n* Security scheme of Swagger Documents.\n*\n* `ISwaggerSecurityScheme` is a data structure representing content of\n* `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n* schemes as an union type like below.\n*\n* @reference https://swagger.io/specification/#security-scheme-object\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport type ISwaggerSecurityScheme =\n| ISwaggerSecurityScheme.IHttpBasic\n| ISwaggerSecurityScheme.IHttpBearer\n| ISwaggerSecurityScheme.IApiKey\n| ISwaggerSecurityScheme.IOpenId\n| ISwaggerSecurityScheme.IOAuth2;\nexport namespace ISwaggerSecurityScheme {\nexport interface IHttpBasic {\ntype: \"http\";\nscheme: \"basic\";\n}\nexport interface IHttpBearer {\ntype: \"http\";\nscheme: \"bearer\";\nbearerFormat?: string;\n}\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n\nexport interface IOpenId {\ntype: \"openIdConnect\";\nopenIdConnectUrl: string;\n}\n\nexport interface IOAuth2 {\ntype: \"oauth2\";\nflows: IOAuth2.IFlowSet;\ndescription?: string;\n}\nexport namespace IOAuth2 {\nexport interface IFlowSet {\nauthorizationCode?: IFlow;\nimplicit?: Omit<IFlow, \"tokenUrl\">;\npassword?: Omit<IFlow, \"authorizationUrl\">;\nclientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n}\nexport interface IFlow {\nauthorizationUrl: string;\ntokenUrl: string;\nrefreshUrl: string;\nscopes?: Record<string, string>;\n}\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia swagger command.At first, create nestia.config.ts file through npx nestia init command. It would be placed on the top level directory of your NestJS backend project. For reference, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Path of controller files\nswagger.output: Path of swagger.json file\n\nWhen you've completed above configuration, just run npx nestia swagger command. Then, swagger.json file would be newly generated, and placed into the $config.swagger.output directory following your nestia.config.ts configuration.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;","special-tags#Special Tags":"","controller-methods#Controller Methods":"Swagger generator @nestia/sdk supports three type of comment tags for controller methods:\nHiding\n@deprecated: mark as deprecated\n@internal: hide, never be shown\n\n\nLabeling\n@summary : short description of endpoint\n@tag {name}: grouppig\n@operationId {value}: manual operation ID\n\n\nSecurity\n@security {key}: security scheme key\n@security {key} {...scopes}: +scopes for OAuth2 type\n\n\n\nAt first, @internal tag is used to hide the controller method from the Swagger Documents. When you use it, the controller method would not be written in the swagger.json file. Otherwise, the @deprecated tag is used to mark the controller method as deprecated. When you use it, Swagger Editor will show the deprecated message about the route method like below.Also, the @summary tag is used to write short description of the endpoint. By the way, the @summary tag can be replaced by writing top sentence ends with . symbol. The other one, @tag {name} tag is used for only groupping.The last one, @security is a tag for security scheme. It specifies target security scheme by writing its key like @security {key}. If target scheme type is OAuth2, and it has configured scopes, you can specify the scopes by writing scopes at the backward like @security {key} read write.For reference, target security schemes must be configured in the nestia.config.ts file. If you use @security tag that is not configured in the nestia.config.ts file, it would be an error. Also, if you've configured @nestia/swagger security decorator like @ApiSecurity, @nestia/sdk also can recognize it too.\n\n\nimport { TypedBody, TypedParam, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\nimport { ApiSecurity } from \"@nestjs/swagger\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"bbs/articles/:section\")\nexport class BbsArticlesController {\n/**\n* Would be shown without any mark.\n*\n* @param section Section code\n* @param input Content to store\n* @returns Newly archived article\n*\n* @tag public\n* @summary Public API\n* @security bearer\n* @security oauth2 read write\n*/\n@TypedRoute.Post()\npublic async store(\n@TypedParam(\"section\") section: string,\n@TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\n...input,\nsection,\n};\n}\n\n/**\n* Deprecated API.\n*\n* Would be marked as \"deprecated\".\n*\n* For reference, top sentence \"Deprecated API.\" can replace the `@summary` tag.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @deprecated\n* @operationId updateArticle\n* @security basic\n* @security bearer\n*/\n@TypedRoute.Put(\":id\")\npublic async update(\n@TypedParam(\"section\") section: string,\n@TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n@TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\n...input,\nid,\nsection,\n};\n}\n\n/**\n* Would not be shown.\n*\n* @internal\n*/\n@ApiSecurity(\"custom\") // LEGACY DECRATOR ALSO CAN BE USED\n@TypedRoute.Delete(\":id\")\npublic erase(\n@TypedParam(\"section\") section: string,\n@TypedParam(\"id\") id: string & tags.Format<\"uuid\">,\n): void {\nsection;\nid;\n}\n}\n\n\n\n{\n\"openapi\": \"3.0.1\",\n\"servers\": [\n{\n\"url\": \"https://github.com/samchon/nestia\",\n\"description\": \"insert your server url\"\n}\n],\n\"info\": {\n\"version\": \"1.0.0\",\n\"title\": \"test\",\n\"description\": \"\",\n\"license\": {\n\"name\": \"ISC\"\n}\n},\n\"paths\": {\n\"/bbs/articles/{section}\": {\n\"post\": {\n\"tags\": [\n\"public\"\n],\n\"operationId\": \"BbsArticlesController.store\",\n\"parameters\": [\n{\n\"name\": \"section\",\n\"in\": \"path\",\n\"schema\": {\n\"type\": \"string\"\n},\n\"description\": \"Section code\",\n\"required\": true\n}\n],\n\"requestBody\": {\n\"description\": \"Content to store\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n}\n}\n},\n\"required\": true\n},\n\"responses\": {\n\"201\": {\n\"description\": \"Newly archived article\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle\"\n}\n}\n}\n}\n},\n\"summary\": \"Public API\",\n\"description\": \"Would be shown without any mark.\",\n\"security\": [\n{\n\"bearer\": []\n},\n{\n\"oauth2\": [\n\"read\",\n\"write\"\n]\n}\n]\n}\n},\n\"/bbs/articles/{section}/{id}\": {\n\"put\": {\n\"deprecated\": true,\n\"tags\": [],\n\"operationId\": \"BbsArticlesController.update\",\n\"parameters\": [\n{\n\"name\": \"section\",\n\"in\": \"path\",\n\"schema\": {\n\"type\": \"string\"\n},\n\"description\": \"Section code\",\n\"required\": true\n},\n{\n\"name\": \"id\",\n\"in\": \"path\",\n\"schema\": {\n\"type\": \"string\",\n\"format\": \"uuid\"\n},\n\"description\": \"Target article ID\",\n\"required\": true\n}\n],\n\"requestBody\": {\n\"description\": \"Content to update\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle.IStore\"\n}\n}\n},\n\"required\": true\n},\n\"responses\": {\n\"201\": {\n\"description\": \"Updated content\",\n\"content\": {\n\"application/json\": {\n\"schema\": {\n\"$ref\": \"#/components/schemas/IBbsArticle\"\n}\n}\n}\n}\n},\n\"summary\": \"Deprecated API\",\n\"description\": \"Deprecated API.\\n\\nWould be marked as \\\"deprecated\\\".\\n\\nFor reference, top sentence \\\"Deprecated API.\\\" can replace the `@summary` tag.\",\n\"security\": [\n{\n\"basic\": []\n},\n{\n\"bearer\": []\n}\n]\n}\n}\n},\n\"components\": {\n\"schemas\": {\n\"IBbsArticle.IStore\": {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\n\"type\": \"string\",\n\"maxLength\": 50,\n\"minLength\": 3\n},\n\"body\": {\n\"type\": \"string\"\n},\n\"files\": {\n\"type\": \"array\",\n\"items\": {\n\"$ref\": \"#/components/schemas/IAttachmentFile\"\n}\n}\n},\n\"nullable\": false,\n\"required\": [\n\"title\",\n\"body\",\n\"files\"\n]\n},\n\"IAttachmentFile\": {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\n\"type\": \"string\",\n\"maxLength\": 255,\n\"minLength\": 1,\n\"nullable\": true\n},\n\"extension\": {\n\"type\": \"string\",\n\"maxLength\": 8,\n\"minLength\": 1,\n\"nullable\": true\n},\n\"url\": {\n\"type\": \"string\",\n\"format\": \"url\"\n}\n},\n\"nullable\": false,\n\"required\": [\n\"name\",\n\"extension\",\n\"url\"\n]\n},\n\"IBbsArticle\": {\n\"type\": \"object\",\n\"properties\": {\n\"id\": {\n\"type\": \"string\",\n\"format\": \"uuid\"\n},\n\"section\": {\n\"type\": \"string\"\n},\n\"created_at\": {\n\"type\": \"string\",\n\"format\": \"date-time\"\n},\n\"title\": {\n\"type\": \"string\",\n\"maxLength\": 50,\n\"minLength\": 3\n},\n\"body\": {\n\"type\": \"string\"\n},\n\"files\": {\n\"type\": \"array\",\n\"items\": {\n\"$ref\": \"#/components/schemas/IAttachmentFile\"\n}\n}\n},\n\"nullable\": false,\n\"required\": [\n\"id\",\n\"section\",\n\"created_at\",\n\"title\",\n\"body\",\n\"files\"\n]\n}\n},\n\"securitySchemes\": {\n\"basic\": {\n\"type\": \"http\",\n\"scheme\": \"basic\"\n},\n\"bearer\": {\n\"type\": \"http\",\n\"scheme\": \"bearer\"\n},\n\"oauth2\": {\n\"type\": \"oauth2\",\n\"flows\": {\n\"implicit\": {\n\"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n\"refreshUrl\": \"https://example.com/api/oauth/refresh\",\n\"scopes\": {\n\"read\": \"read authority\",\n\"write\": \"write authority\"\n}\n}\n}\n},\n\"custom\": {\n\"type\": \"apiKey\",\n\"in\": \"header\",\n\"name\": \"Authorization\"\n}\n}\n}\n}\n\n\n\nimport type { INestiaConfig } from \"@nestia/sdk\";\n\nexport const NESTIA_CONFIG: INestiaConfig = {\ninput: [\"src/controllers\"],\noutput: \"src/api\",\nswagger: {\noutput: \"swagger.json\",\noperationId: (props) => `${props.class}.${props.function}`,\nsecurity: {\n//----\n// YOU CAN CHOOSE ANY SECURITY SCHEMES LIKE\n//----\n// @security basic\n// @security bearer\n// @security oauth2 read write\n// @security custom\nbasic: {\ntype: \"http\",\nscheme: \"basic\",\n},\nbearer: {\ntype: \"http\",\nscheme: \"bearer\",\n},\noauth2: {\ntype: \"oauth2\",\nflows: {\nimplicit: {\nauthorizationUrl: \"https://example.com/api/oauth/dialog\",\nrefreshUrl: \"https://example.com/api/oauth/refresh\",\nscopes: {\n//----\n// YOU CAN CHOOSE ANY SCOPES\n//----\n// (@security oauth2 read write) -> BOTH OF THEM\n// (@security oauth2 read) -> ONE OF THEM\n// (@security oauth) -> NOTHING\n\"read\": \"read authority\",\n\"write\": \"write authority\",\n},\n},\n},\n},\ncustom: {\ntype: \"apiKey\",\nin: \"header\",\nname: \"Authorization\",\n},\n},\n},\n};\nexport default NESTIA_CONFIG;\n\n\n\n/**\n* Security scheme of Swagger Documents.\n*\n* `ISwaggerSecurityScheme` is a data structure representing content of\n* `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n* schemes as an union type like below.\n*\n* @reference https://swagger.io/specification/#security-scheme-object\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport type ISwaggerSecurityScheme =\n| ISwaggerSecurityScheme.IHttpBasic\n| ISwaggerSecurityScheme.IHttpBearer\n| ISwaggerSecurityScheme.IApiKey\n| ISwaggerSecurityScheme.IOpenId\n| ISwaggerSecurityScheme.IOAuth2;\nexport namespace ISwaggerSecurityScheme {\nexport interface IHttpBasic {\ntype: \"http\";\nscheme: \"basic\";\n}\nexport interface IHttpBearer {\ntype: \"http\";\nscheme: \"bearer\";\nbearerFormat?: string;\n}\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n\nexport interface IOpenId {\ntype: \"openIdConnect\";\nopenIdConnectUrl: string;\n}\n\nexport interface IOAuth2 {\ntype: \"oauth2\";\nflows: IOAuth2.IFlowSet;\ndescription?: string;\n}\nexport namespace IOAuth2 {\nexport interface IFlowSet {\nauthorizationCode?: IFlow;\nimplicit?: Omit<IFlow, \"tokenUrl\">;\npassword?: Omit<IFlow, \"authorizationUrl\">;\nclientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n}\nexport interface IFlow {\nauthorizationUrl: string;\ntokenUrl: string;\nrefreshUrl: string;\nscopes?: Record<string, string>;\n}\n}\n}","dto-properties#DTO Properties":"https://swagger.io/docs/specification/data-models/data-types/You can utilize comments and tags to construct special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. When you utilize Special tags of typia, they would be placed into the proper properties of IJsonSchema. Below is the list of supported type and comment tags in the @nestia/sdk.Also, such type and comment tags of DTO properties can be used to enhance validation logic of @nestia/core library. Especially, @TypedBody.${method}(), @TypedParam(), @TypedRoute() and @TypedQuery() functions can use those tags for additional validation.Let's see how those type and comment tags work with example code.\nnumber\nnumber & Type<{keyword}>\nint32\nuint32\nuint64\nint64\nfloat\ndouble\n\n\nnumber & Minimum<{number}>\nnumber & Maximum<{number}>\nnumber & ExclusiveMaximum<{number}>\nnumber & ExclusiveMinimum<{number}>\nnumber & MultipleOf<{number}>\n\n\nbigint\nbigint & Type<{keyword}>\nint64\nuint64\n\n\nbigint & Minimum<{bigint}>\nbigint & Maximum<{bigint}>\nbigint & ExclusiveMaximum<{bigint}>\nbigint & ExclusiveMinimum<{bigint}>\nbigint & MultipleOf<{bigint}>\n\n\nstring\nstring & MinLength<{number}>\nstring & MaxLength<{number}>\nstring & Pattern<{regex}>\nstring & Format<{keyword}>\nemail\nuuid\nipv4\nipv6\nurl\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\n\n\n\n\n\n\nexport interface SpecialTag {\n/**\n* Deprecated tags are just used for marking.\n*\n* @title Unsigned integer\n* @deprecated\n*/\ntype: number & tags.Type<\"uint32\">;\n\n/**\n* Internal tagged property never be shown in JSON schema.\n*\n* It even doesn't be shown in other `typia` functions like `assert<T>()`.\n*\n* @internal\n*/\ninternal: number[];\n\n/**\n* Hidden tagged property never be shown in JSON schema.\n*\n* However, it would be shown in other `typia` functions like `stringify<T>()`.\n*\n* @hidden\n*/\nhidden: boolean;\n\n/**\n* You can limit the range of number.\n*\n* Also, you can configure `default` property by comment tag.\n*\n* @default 30\n*/\nnumber?: number & tags.ExclusiveMinimum<19> & tags.Maximum<100>;\n\n/**\n* You can limit the length of string.\n*/\nstring: string & tags.MinLength<3>;\n\n/**\n* You can limit the pattern of string.\n*/\npattern: string & tags.Pattern<\"^[a-z]+$\">;\n\n/**\n* You can limit the format of string.\n*/\nformat: null | (string & tags.Format<\"date-time\">);\n\n/**\n* You also can perform union type in type tags.\n*/\nip: string & (tags.Format<\"ipv4\"> | tags.Format<\"ipv6\">);\n\n/**\n* In the Array case, only type tags can limit elements' type.\n*/\narray: Array<string & tags.Format<\"uuid\">>\n& tags.MinItems<3>\n& tags.MaxItems<100>;\n}\n\n\n\n{\n\"SpecialTag\": {\n\"type\": \"object\",\n\"properties\": {\n\"type\": {\n\"deprecated\": true,\n\"title\": \"Unsigned integer\",\n\"description\": \"Deprecated tags are just used for marking.\",\n\"type\": \"integer\"\n},\n\"number\": {\n\"description\": \"You can limit the range of number.\\n\\nAlso, you can configure `default` property by comment tag.\",\n\"type\": \"number\",\n\"minimum\": 19,\n\"exclusiveMinimum\": true,\n\"maximum\": 100,\n\"default\": 30\n},\n\"string\": {\n\"description\": \"You can limit the length of string.\",\n\"type\": \"string\",\n\"minLength\": 3\n},\n\"pattern\": {\n\"description\": \"You can limit the pattern of string.\",\n\"type\": \"string\",\n\"pattern\": \"^[a-z]+$\"\n},\n\"format\": {\n\"description\": \"You can limit the format of string.\",\n\"type\": \"string\",\n\"format\": \"date-time\",\n\"nullable\": true\n},\n\"ip\": {\n\"oneOf\": [\n{\n\"description\": \"You also can perform union type in type tags.\",\n\"type\": \"string\",\n\"format\": \"ipv4\"\n},\n{\n\"description\": \"You also can perform union type in type tags.\",\n\"type\": \"string\",\n\"format\": \"ipv6\"\n}\n],\n\"description\": \"You also can perform union type in type tags.\"\n},\n\"array\": {\n\"description\": \"In the Array case, only type tags can limit elements' type.\",\n\"type\": \"array\",\n\"items\": {\n\"description\": \"In the Array case, only type tags can limit elements' type.\",\n\"type\": \"string\",\n\"format\": \"uuid\"\n},\n\"maxItems\": 100,\n\"minItems\": 3\n}\n},\n\"nullable\": false,\n\"required\": [\n\"type\",\n\"string\",\n\"pattern\",\n\"format\",\n\"ip\",\n\"array\"\n],\n}\n}\n\n\n\n/**\n* Security schema of Swagger Documents.\n*\n* `ISwaggerSecurityScheme` is a data structure representing content of\n* `securitySchemes` in `swagger.json` file. It is composed with 5 types of security\n* schemes as an union type like below.\n*\n* @reference https://swagger.io/specification/#security-scheme-object\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport type ISwaggerSecurityScheme =\n| ISwaggerSecurityScheme.IHttpBasic\n| ISwaggerSecurityScheme.IHttpBearer\n| ISwaggerSecurityScheme.IApiKey\n| ISwaggerSecurityScheme.IOpenId\n| ISwaggerSecurityScheme.IOAuth2;\nexport namespace ISwaggerSecurityScheme {\nexport interface IHttpBasic {\ntype: \"http\";\nscheme: \"basic\";\n}\nexport interface IHttpBearer {\ntype: \"http\";\nscheme: \"bearer\";\nbearerFormat?: string;\n}\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n\nexport interface IOpenId {\ntype: \"openIdConnect\";\nopenIdConnectUrl: string;\n}\n\nexport interface IOAuth2 {\ntype: \"oauth2\";\nflows: IOAuth2.IFlowSet;\ndescription?: string;\n}\nexport namespace IOAuth2 {\nexport interface IFlowSet {\nauthorizationCode?: IFlow;\nimplicit?: Omit<IFlow, \"tokenUrl\">;\npassword?: Omit<IFlow, \"authorizationUrl\">;\nclientCredentials?: Omit<IFlow, \"authorizationUrl\">;\n}\nexport interface IFlow {\nauthorizationUrl: string;\ntokenUrl: string;\nrefreshUrl: string;\nscopes?: Record<string, string>;\n}\n}\n}","distribution#Distribution":"You can choose two options for swagger.json file distribution.The 1st is publishing the swagger.json file in a public repo, and showing it through Swagger Editor like below:\nsamchon/nestia-template: Swagger Editor\nsamchon/fake-iamport-server: Swagger Editor\nsamchon/fake-toss-payments-server: Swagger Editor\n\nThe 2nd way is to hosting the swagger.json file in the NestJS backend server.Read below example code, and follow it on yours:\nimport fs from \"fs\";\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule } from '@nestjs/swagger';\n\nasync function open(): Promise<void> {\nconst app = await NestFactory.create(...);\n\nconst docs = require(\"...write swagger.json path\");\ndocs.servers = [\n{ url: \"write your server URL\" }\n];\nSwaggerModule.setup(\"swagger\", app, docs);\n\nawait app.listen(8080);\n}"}},"/docs/setup":{"title":"Setup","data":{"":"","boilerplate#Boilerplate":"npx nestia start <directory>\nJust run above npx nestia start <directory> command.Boilerplate would be automatically constructed in the <directory>.","setup-wizard#Setup Wizard":"npm install --save-dev nestia\nnpx nestia setup\n\n\n\npnpm install --save-dev nestia\npnpm nestia setup --manager pnpm\n\n\n\nyarn add -D nestia\nyarn nestia setup --manager yarn\n\n\nWhen you want to setup nestia in exiting project, just run above npx nestia setup command.Setup Wizard will install and configure everything automatically.","webpack#Webpack":"# SETUP NESTIA\nnpm install --save-dev nestia\nnpx nestia setup\n\n# INSTALL TS-LOADER & WEBPACK\nnpm install --save-dev ts-loader\nnpm install --save-dev webpack webpack-cli webpack-node-externals\n\n\n\n# SETUP NESTIA\npnpm install --save-dev nestia\npnpm nestia setup --manager pnpm\n\n# INSTALL TS-LOADER & WEBPACK\npnpm install --save-dev ts-loader\npnpm install --save-dev webpack webpack-cli webpack-node-externals\n\n\n\n# SETUP NESTIA\nyarn add -D nestia\nyarn nestia setup --manager yarn\n\n# INSTALL TS-LOADER & WEBPACK\nyarn add -D ts-loader\nyarn add -D webpack webpack-cli webpack-node-externals\n\n\nWhen you want to bundle your NestJS project into a single file, you have to install webpack manually.Never run nest build --webpack command of @nestjs/cli, because it is not compatible with nestia.\nconst path = require(\"path\");\nconst nodeExternals = require('webpack-node-externals');\n\nmodule.exports = {\n// CUSTOMIZE HERE\nentry: ['./src/main.ts'],\noutput: {\npath: path.join(__dirname, 'dist'),\nfilename: 'main.js',\n},\noptimization: {\nminimize: false\n},\n\n// JUST KEEP THEM\nexternals: [nodeExternals()],\nmode: 'development',\ntarget: 'node',\nmodule: {\nrules: [\n{\ntest: /\\.ts$/,\nexclude: /node_modules/,\nloader: 'ts-loader',\n}\n]\n},\nresolve: {\nextensions: ['.tsx', '.ts', '.js'],\n},\n};\nAfter installing both nestia and webpack, configure webpack.config.js file like above.If required, update entry, output or optimization properties as you want.\n\n\nnpx webpack\n\n\n\npnpm webpack\n\n\n\nyarn webpack\n\n\nAt last, you can bundle your NestJS project into a single file, just by running npx webpack command.","nx#NX":"npm install --save-dev nestia\nnpx nestia setup\n\n\n\npnpm install --save-dev nestia\npnpm nestia setup --manager pnpm\n\n\n\nyarn add -D nestia\nyarn nestia setup --manager yarn\n\n\nAfter install nestia like above, you have to modify project.json on each app you use typia like below.\n\"targets\": {\n\"build\": {\n...\n\"options\": {\n...\n\"target\": \"node\",\n\"compiler\": \"tsc\",\n\"transformers\": [\n\"typia/lib/transform\",\n{\n\"name\": \"@nestia/core/lib/transform\",\n\"options\": {\n\"validate\": \"assert\",\n\"stringify\": \"assert\"\n}\n}\n]\n}\n},\n...\n}","manual-setup#Manual Setup":"# COMPILERS\nnpm install --save-dev typescript\nnpm install --save-dev ts-node\nnpm install --save-dev ts-patch\n\n# NESTIA\nnpm install --save-dev nestia\nnpm install --save-dev @nestia/sdk\nnpm install --save @nestia/core\nnpm install --save @nestia/e2e\nnpm install --save typia\n\n\n\n# COMPILERS\npnpm install --save-dev typescript\npnpm install --save-dev ts-node\npnpm install --save-dev ts-patch\n\n# NESTIA\npnpm install --save-dev nestia\npnpm install --save-dev @nestia/sdk\npnpm install --save @nestia/core\npnpm install --save @nestia/e2e\npnpm install --save typia\n\n\n\n# COMPILERS\nyarn add -D typescript\nyarn add -D ts-node\nyarn add -D ts-patch\n\n# NESTIA\nyarn add -D nestia\nyarn add -D @nestia/sdk\nyarn add @nestia/core\nyarn add @nestia/e2e\nyarn add typia\n\n\nIf you want to install nestia manually, you have to install ts-node and ts-patch modules as well as typescript. After installing those compilers, install nestia libraries like above.\n{\n\"strict\": true,\n\"strictNullChecks\": true,\n\"compilerOptions\": {\n\"plugins\": [\n{ \"transform\": \"typia/lib/transform\" },\n{\n\"transform\": \"@nestia/core/lib/transform\",\n\"validate\": \"assert\",\n\"stringify\": \"assert\",\n},\n],\n},\n}\nAfter that, configure tsconfig.json file like above.As @nestia/core and typia are generating optimal validation and JSON serialization code through transformation, you've to configure them as plugins. For reference, you can choose which typia functions to be used in validation and JSON serialization.\nis: check validation only, and do not reveal the reason why\nassert: find the 1st type error with reason\nvalidate: find every type errors with detailed reasons\n\nAlso, never forget to configure strict (or strictNullChecks) as true. It is essential option for modern TypeScript development.\n{\n\"scripts\": {\n\"postinstall\": \"ts-patch install\"\n}\n}\n\n\n\nnpm run postinstall\n\n\n\npnpm run postinstall\n\n\n\nyarn run postinstall\n\n\nAt last, configure npm run postinstall command like above.Of course, you've to run the npm run postinstall command after configuration.For reference, ts-patch is an helper library of TypeScript compiler that supporting custom transformations by plugins. With the ts-patch setup and plugin configurations, whenever you run tsc command, your @nestia/core decorator function call statements would be transformed to the optimal operation codes in the compiled JavaScript files.\n\n\n\nIf manual setup is difficult, just use the Setup Wizard \\o/.","standard-typescript-only#Standard TypeScript Only":"If you're using @nestia/core module, you've to use only standard TypeScript compiler.Do you remember? @nestia/core boosts up runtime validation and JSON serialization through AOT compilation. By the way, @nestia/core performs the AOT compilation through standard TypeScript compiler API. Therefore, if you want to utilize those superfast decorators of @nestia/core module, you have to use only standard TypeScript compiler.I also know that non-standard compilers are faster than standard. However, all of them are erasing type information, and skipping type checking for rapid compilation. By the way, without type information, @nestia/core can't do anything. It is the reason why @nestia/core does not support them.\nStandard TypeScript Compiler (keep type info)\nMicrosoft/TypeScript\n\n\nNon-standard TypeScript Compilers (erase type info)\nSWC\nESBuild\nBabel\n\n\n\n\n\n\n\nSWC author is preparing a new project STC, and it does not erase type info.Therefore, nestia will support it."}}}