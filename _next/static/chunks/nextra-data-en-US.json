{"/docs/core/TypedBody":{"title":"TypedBody","data":{"":"","outline#Outline":"export function TypedBody(): ParameterDecorator;\nRequest body decorator 20,000x faster, even easy to use.@TypedBody() is a decorator function parsing application/json typed request body, and validates the request body value type through typia.assert<T>() function. If the request body is not following the promised type, 400 bad request error would be thrown.It is almost same with original @Body() function of NestJS, however, 20,000x faster.Also, @TypedBody() is much more easier to use than class-validator, because it can use pure TypeScript type. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle.IUpdate interface type. You may understand what it means.","how-to-use#How to use":"export interface IBbsArticle extends IBbsArticle.IStore {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format date-time\n*/\ncreated_at: string;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\n/**\n* @minLength 3\n* @maxLength 50\n*/\ntitle: string;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\n/**\n* @minLengt 1\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* @minLength 1\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* @format url\n*/\nurl: string;\n}\n\n\n\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Post()\npublic async store(\n@TypedBody() input: IBbsArticle.IStore\n): Promise<IBbsArticle> {\nreturn {\n...input,\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\n}\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nstore(input) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn Object.assign(Object.assign({}, input), { id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\", created_at: \"2023-04-23T12:04:54.168Z\" });\n});\n}\n};\n__decorate([\ncore_1.TypedRoute.Post({ type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at)) && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $string = core_1.TypedRoute.Post.string;\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nconst $so0 = input => `{\"id\":${\"\\\"\" + input.id + \"\\\"\"},\"created_at\":${\"\\\"\" + input.created_at + \"\\\"\"},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${\"\\\"\" + input.url + \"\\\"\"}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); }\n}),\n__param(0, (0, core_1.TypedBody)({\ntype: \"assert\",\nassert: input => {\nconst $guard = core_1.TypedBody.guard;\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst __is = input => {\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst $io0 = input => \"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle.IStore\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"store\", null);\nBbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\nexports.BbsArticlesController = BbsArticlesController;\n\n\nJust call @TypedBody() function on the request body property, that's all.Nestia will analyze your type (IBbsArticle.IUpdate), and writes optimal code for the target type, in the compilation level. If you click the \"Complied JavaScript File\" tab of above, you can see the optimal validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedBody.","comment-tags#Comment Tags":"You can enhance validation logic, of @TypedBody(), through comment tags.You know what? @TypedBody() utilizes typia.assert<T>() function for request body data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, the \"Comment Tag\" means a comment starting from @ symbol. It follows @${name} ${value} format, and you can add multiple comment tags per each property.With those comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such comment tags, in a few minutes.\ntypia > Validators > Comment Tags\nOutline\nSupported Tags\nCustomization\n\n\n\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = typia.createIs<CommentTag>();\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = (input) => {\nconst $is_datetime = typia.createIs.is_datetime;\nconst $is_uuid = typia.createIs.is_uuid;\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nparseInt(input.type) === input.type &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\n100 >= input.number)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\nRegExp(/^[a-z]+$/).test(input.pattern) &&\n(null === input.format ||\n(\"string\" === typeof input.format && $is_datetime(input.format))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\n100 >= input.array.length &&\ninput.array.every((elem) => \"string\" === typeof elem && $is_uuid(elem));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};","benchmark#Benchmark":"Super-fast and super-safe.Nestia utilizes typia, and NestJS uses class-validator. One thing amazing is, typia is maximum 20,000x faster than class-validator of NestJS. Color of class-transformer is skyblue, and can you find the skyblue color in the below benchmark graph? It may hard to find because class-validator is extremely slow.\nMeasured on Intel i5-1135g7, Surface Pro 8\nFurthermore, while other libraries can't validate complicate union types, typia can validate every TypeScript types. However, in the class-validator case, it always be failed when any type of complicate comes. I can't understand why NestJS has adopted such slow and unstable library.Moreover, only typia can utilize pure TypeScript type, without any extra schema definition. Beside, all of other libraries require extra and duplicated schema definition, different with pure TypeScript type. Nestia is using such wonderful, super-fast and super-fast typia library.\nTypeBox requires TypeBox schema\najv requires JSON schema definition\nio-ts requires io-ts schema\nzod requires zod schema\nclass-validator requires DTO class with decorator function calls\n\n\nComponents\ttypia\tTypeBox\tajv\tio-ts\tzod\tC.V.\tEasy to use\t✅\t❌\t❌\t❌\t❌\t❌\tObject (simple)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (recursive)\t✔\t❌\t✔\t✔\t✔\t✔\t✔\tObject (union, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tObject (union, explicit)\t✔\t✔\t✔\t✔\t✔\t❌\tObject (additional tags)\t✔\t✔\t✔\t✔\t✔\t✔\tObject (template literal types)\t✔\t✔\t✔\t❌\t❌\t❌\tObject (dynamic properties)\t✔\t✔\t✔\t❌\t❌\t❌\tArray (rest tuple)\t✅\t❌\t❌\t❌\t❌\t❌\tArray (hierarchical)\t✔\t✔\t✔\t✔\t✔\t✔\tArray (recursive)\t✔\t✔\t✔\t✔\t✔\t❌\tArray (recursive, union)\t✔\t✔\t❌\t✔\t✔\t❌\tArray (R+U, implicit)\t✅\t❌\t❌\t❌\t❌\t❌\tUltimate Union Type\t✅\t❌\t❌\t❌\t❌\t❌\n\nC.V. means class-validator"}},"/docs/core/TypedRoute":{"title":"TypedRoute","data":{"":"","outline#Outline":"export namespace TypedRoute {\nexport function Get(path?: string): MethodDecorator;\nexport function Post(path?: string): MethodDecorator;\nexport function Patch(path?: string): MethodDecorator;\nexport function Put(path?: string): MethodDecorator;\nexport function Delete(path?: string): MethodDecorator;\n}\nRoute decorators 200x faster, even type safe and easy to use.TypedRoute is a namespaced module containing router decorators utilizing typia.assertStringify<T>() function. Those decorators are almost same with original NestJS, but TypedRoute can boost up JSON serialization speed maximum 200x times faster than class-transformer, therefore much faster than original NestJS.Furthermore, as TypedRoute utilizes typia.assertStringify<T>() function, it is even type safe. The typia.assertStringify<T>() function validates response data type, via typia.assert<T>() function, before JSON serialization. Therefore, if you try to return wrong typed value, it would be blocked with 500 internal server error.Moreover, TypedRoute is much easier than class-transformer, because it just needs only pure TypeScript type definition. If you can't understand the word \"pure TypeScript type\", then move to below #How to use section and read the IBbsArticle interface type. You may understand what it means.","how-to-use#How to use":"export interface IBbsArticle extends IBbsArticle.IStore {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format date-time\n*/\ncreated_at: string;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\n/**\n* @minLength 3\n* @maxLength 50\n*/\ntitle: string;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\n/**\n* @minLengt 1\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* @minLength 1\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* @format url\n*/\nurl: string;\n}\n\n\n\nimport { TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n/**\n* Get random article for testing.\n*/\n@TypedRoute.Get(\"random\")\npublic async random(): Promise<IBbsArticle> {\nreturn {\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ntitle: \"Hello nestia users\",\nbody: \"Just use `TypedRoute.Get()` function like this\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\nfiles: [],\n};\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\n/**\n* Get random article for testing.\n*/\nrandom() {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn {\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ntitle: \"Hello nestia users\",\nbody: \"Just use `TypedRoute.Get()` function like this\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\nfiles: [],\n};\n});\n}\n};\n__decorate([\ncore_1.TypedRoute.Get(\"random\", {\ntype: \"assert\",\nassert: input => {\nconst assert = input => {\nconst $guard = core_1.TypedRoute.Get.guard;\nconst $is_uuid = core_1.TypedRoute.Get.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Get.is_datetime;\nconst $is_custom = core_1.TypedRoute.Get.is_custom;\nconst $is_url = core_1.TypedRoute.Get.is_url;\nconst __is = input => {\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at)) && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n};\nconst stringify = input => {\nconst $string = core_1.TypedRoute.Get.string;\nconst $is_uuid = core_1.TypedRoute.Get.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Get.is_datetime;\nconst $is_custom = core_1.TypedRoute.Get.is_custom;\nconst $is_url = core_1.TypedRoute.Get.is_url;\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nconst $so0 = input => `{\"id\":${\"\\\"\" + input.id + \"\\\"\"},\"created_at\":${\"\\\"\" + input.created_at + \"\\\"\"},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${\"\\\"\" + input.url + \"\\\"\"}}`;\nreturn $so0(input);\n};\nreturn stringify(assert(input));\n}\n}),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", []),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"random\", null);\nBbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\nexports.BbsArticlesController = BbsArticlesController;\n\n\nJust call @TypedRoute.${method}() function on the target method, that's all.Nestia will analyze your type (IBbsArticle), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript File\" tab of above, you can see the optimal validation and JSON serialization code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of TypedRoute.","comment-tags#Comment Tags":"You can enhance validation logic, of TypedRoute, through comment tags.You know what? @TypedRoute.${method}() functions are using typia.assertStringify<T>() function, that is combined with typia.assert<T>() and typia.stringify<T>() functions. It is the secret of @TypedRoute.${method}() functions, which can validates response body data type before JSON serialization, and throws 500 internal server error when the data type is not matched.Also, as typia.assert<T>() function can utililze comment tags for additional validation, TypedRoute also can utillze them, too. For reference, the \"Comment Tag\" means a comment starting from @ symbol. It follows @${name} ${value} format, and you can add multiple comment tags per each property.Anyway, with those comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia(opens in a new tab), and see the example code. You may understand how to utilize such comment tags, in a few minutes.\ntypia > Validators > Comment Tags\nOutline\nSupported Tags\nCustomization\n\n\n\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = typia.createIs<CommentTag>();\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = (input) => {\nconst $is_datetime = typia.createIs.is_datetime;\nconst $is_uuid = typia.createIs.is_uuid;\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nparseInt(input.type) === input.type &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\n100 >= input.number)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\nRegExp(/^[a-z]+$/).test(input.pattern) &&\n(null === input.format ||\n(\"string\" === typeof input.format && $is_datetime(input.format))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\n100 >= input.array.length &&\ninput.array.every((elem) => \"string\" === typeof elem && $is_uuid(elem));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};","benchmark#Benchmark":"","json#JSON":"Comparing JSON serialization speed, typia is maximum 200x faster than class-transformer.For reference, Nestia is using typia, and NestJS is using class-transformer. The other one fast-json-stringify is made and used by fastify (do not mean NestJS fastify mode, but mean pure fastify library. NestJS fastify mode still utilizes class-transformer), and it requires JSON schema definition.From above benchmark graph, you can see that class-transformer is extremely slower than others, even including built-in JSON.stringify() function. I can't understand why NestJS has adopted such slow and difficult library. The other fast-json-stringify is enough faster, but it needs extra schema definition like class-validator, therefore not easy to use.\ntypia needs only pure TypeScript type.\nclass-transformer requires DTO class with decorator function calls.\nfast-json-stringify requires JSON schema definition.\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8","server#Server":"Looking at above benchmark, someone may ask:\nJSON serialization speed affects on the server performance?I think that the JSON serialization is just a tiny thing in the server side, isn't it?\nMy answer is, \"Yes, it affects on the server performance\".Most operations in NodeJS server are asynchronously executed in background thread, what are called \"event based non-blocking I/O model\". However, JSON serialization is a synchronous operation running on the main thread. Therefore, if the JSON serialization speed is slow, it makes the entire server program slow.I'll show you the benchmark result that, how JSON serizliation speed affects on the server performance.\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/core/TypedParam":{"title":"TypedParam","data":{"":"","outline#Outline":"export function TypedParam(name: string): ParameterDecorator;\nexport function TypedParam(\nnane: string,\ntype: \"uuid\" | \"date\"\n): ParameterDecorator;\nType safe path parameter decorator.@TypedParam() is a decorator parsing path parameter.It's almost same with original @Param() function of NestJS, however, @TypedParam() is more type safe.As @TypedParam() can anlayze source code in the compilation level, it can specify parameter type by itself. Also, while NestJS cannot distinguish nullable type and consider every parameter value as a string type, @TypedParam() can do it. Furthermore, @TypedParam() provides special type \"uuid\" and \"date\".Let's read below example code, and see how @TypedParam() works.","how-to-use#How to use":"import { TypedParam } from \"@nestia/core\";\nimport { Controller, Get } from \"@nestjs/common\";\n\n@Controller(\"parameters\")\nexport class ParametersController {\n@Get(\"number\")\npublic async number(\n@TypedParam(\"value\") value: number | null,\n): Promise<number | null> {\nreturn value;\n}\n\n@Get(\"string\")\npublic async string(\n@TypedParam(\"value\") value: string,\n): Promise<string> {\nreturn value;\n}\n\n@Get(\"uuid\")\npublic async uuid(\n@TypedParam(\"value\", \"uuid\") value: string\n): Promise<string> {\nreturn value;\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParametersController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet ParametersController = class ParametersController {\nnumber(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\nstring(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\nuuid(value) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn value;\n});\n}\n};\n__decorate([\n(0, common_1.Get)(\"number\"),\n__param(0, (0, core_1.TypedParam)(\"value\", \"number\", true)),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"number\", null);\n__decorate([\n(0, common_1.Get)(\"string\"),\n__param(0, (0, core_1.TypedParam)(\"value\", \"string\", false)),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [String]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"string\", null);\n__decorate([\n(0, common_1.Get)(\"uuid\"),\n__param(0, (0, core_1.TypedParam)(\"value\", \"uuid\", false)),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [String]),\n__metadata(\"design:returntype\", Promise)\n], ParametersController.prototype, \"uuid\", null);\nParametersController = __decorate([\n(0, common_1.Controller)(\"parameters\")\n], ParametersController);\nexports.ParametersController = ParametersController;\n\n\nJust call @TypedParam() function on the path paremeter, that's all.If you want to special parameter type \"uuid\" or \"date\", write it as the second argument.When wrong typed value comes, 400 bad request error would be thrown.","restriction#Restriction":"@TypedParam() allows only atomic type.\nboolean\nnumber\nstring\nuuid\ndate: YYYY-MM-DD\n\nAlso, @TypedParam() allows nullable like number | null, but undefindable type is not.\nnumber | null is allowed\nstring | undefined is prohibited\n\nIf you violate above condition, and try to declare object or union type, compilation error would be occured:\nError on nestia.core.TypedParam(): only atomic type is allowed"}},"/docs/core/TypedQuery":{"title":"TypedQuery","data":{"":"","outline#Outline":"export function TypedQuery(): ParameterDecorator;\nType safe URL query decorator.@TypedQuery() is a decorator parsing URL query.It's almost same with original @Query() function of NestJS, but @TypedQuery() is more stable and general.While NestJS does not support query type validation, @TypedQuery() validates the request query type and throws 400 bad request error when mismatched. Also, while NestJS does not support property type (@Query() only supports string typed properties), @TypedQuery() can define variable property types like number or boolean.\nWhat the query parameter is?This is the query parameter!\nname=Samchon&age=20&sex=male","how-to-use#How to use":"export namespace IBbsArticle {\nexport interface ISummary {\n/**\n* @format uuid\n*/\nid: string;\n\nwriter: string;\n\n/**\n* @minLength 3\n* @maxLength 50\n*/\ntitle: string;\n\n/**\n* @format date-time\n*/\ncreated_at: string;\n}\n}\n\n\n\nexport interface IPage<T> {\ndata: T[];\npagination: IPage.IPagination;\n}\nexport namespace IPage {\n/**\n* Page request data\n*/\nexport interface IRequest {\n/**\n* @type uint\n*/\npage?: number;\n\n/**\n* @type uint\n*/\nlimit?: number;\n}\n\n/**\n* Page information.\n*/\nexport interface IPagination {\n/**\n* @type uint\n*/\ncurrent: number;\n\n/**\n* @type uint\n*/\nlimit: number;\n\n/**\n* @type uint\n*/\nrecords: number;\n\n/**\n* @type uint\n*/\npages: number;\n}\n}\n\n\n\nimport { TypedQuery, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\nimport { IPage } from \"./IPage\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Get()\npublic async index(\n@TypedQuery() query: IPage.IRequest\n): Promise<IPage<IBbsArticle.ISummary>> {\nreturn {\npagination: {\ncurrent: query.page ?? 1,\nlimit: query.limit ?? 100,\nrecords: 0,\npages: 0,\n},\ndata: [],\n};\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nindex(query) {\nvar _a, _b;\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn {\npagination: {\ncurrent: (_a = query.page) !== null && _a !== void 0 ? _a : 1,\nlimit: (_b = query.limit) !== null && _b !== void 0 ? _b : 100,\nrecords: 0,\npages: 0,\n},\ndata: [],\n};\n});\n}\n};\n__decorate([\ncore_1.TypedRoute.Get({ type: \"assert\", assert: input => { const assert = input => {\nconst $guard = core_1.TypedRoute.Get.guard;\nconst $is_uuid = core_1.TypedRoute.Get.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Get.is_datetime;\nconst __is = input => {\nconst $is_uuid = core_1.TypedRoute.Get.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Get.is_datetime;\nconst $io0 = input => Array.isArray(input.data) && input.data.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)) && (\"object\" === typeof input.pagination && null !== input.pagination && $io2(input.pagination));\nconst $io1 = input => \"string\" === typeof input.id && $is_uuid(input.id) && \"string\" === typeof input.writer && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at));\nconst $io2 = input => \"number\" === typeof input.current && !Number.isNaN(input.current) && parseInt(input.current) === input.current && 0 <= input.current && (\"number\" === typeof input.limit && !Number.isNaN(input.limit) && parseInt(input.limit) === input.limit && 0 <= input.limit) && (\"number\" === typeof input.records && !Number.isNaN(input.records) && parseInt(input.records) === input.records && 0 <= input.records) && (\"number\" === typeof input.pages && !Number.isNaN(input.pages) && parseInt(input.pages) === input.pages && 0 <= input.pages);\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (Array.isArray(input.data) || $guard(_exceptionable, {\npath: _path + \".data\",\nexpected: \"Array<IBbsArticle.ISummary>\",\nvalue: input.data\n})) && input.data.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".data[\" + _index1 + \"]\",\nexpected: \"IBbsArticle.ISummary\",\nvalue: elem\n})) && $ao1(elem, _path + \".data[\" + _index1 + \"]\", true && _exceptionable)) && ((\"object\" === typeof input.pagination && null !== input.pagination || $guard(_exceptionable, {\npath: _path + \".pagination\",\nexpected: \"IPage.IPagination\",\nvalue: input.pagination\n})) && $ao2(input.pagination, _path + \".pagination\", true && _exceptionable));\nconst $ao1 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.writer || $guard(_exceptionable, {\npath: _path + \".writer\",\nexpected: \"string\",\nvalue: input.writer\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n}));\nconst $ao2 = (input, _path, _exceptionable = true) => (\"number\" === typeof input.current && !Number.isNaN(input.current) && (parseInt(input.current) === input.current || $guard(_exceptionable, {\npath: _path + \".current\",\nexpected: \"number (@type uint)\",\nvalue: input.current\n})) && (0 <= input.current || $guard(_exceptionable, {\npath: _path + \".current\",\nexpected: \"number (@type uint)\",\nvalue: input.current\n})) || $guard(_exceptionable, {\npath: _path + \".current\",\nexpected: \"number\",\nvalue: input.current\n})) && (\"number\" === typeof input.limit && !Number.isNaN(input.limit) && (parseInt(input.limit) === input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type uint)\",\nvalue: input.limit\n})) && (0 <= input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type uint)\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number\",\nvalue: input.limit\n})) && (\"number\" === typeof input.records && !Number.isNaN(input.records) && (parseInt(input.records) === input.records || $guard(_exceptionable, {\npath: _path + \".records\",\nexpected: \"number (@type uint)\",\nvalue: input.records\n})) && (0 <= input.records || $guard(_exceptionable, {\npath: _path + \".records\",\nexpected: \"number (@type uint)\",\nvalue: input.records\n})) || $guard(_exceptionable, {\npath: _path + \".records\",\nexpected: \"number\",\nvalue: input.records\n})) && (\"number\" === typeof input.pages && !Number.isNaN(input.pages) && (parseInt(input.pages) === input.pages || $guard(_exceptionable, {\npath: _path + \".pages\",\nexpected: \"number (@type uint)\",\nvalue: input.pages\n})) && (0 <= input.pages || $guard(_exceptionable, {\npath: _path + \".pages\",\nexpected: \"number (@type uint)\",\nvalue: input.pages\n})) || $guard(_exceptionable, {\npath: _path + \".pages\",\nexpected: \"number\",\nvalue: input.pages\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage<IBbsArticle.ISummary>\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $string = core_1.TypedRoute.Get.string;\nconst $is_uuid = core_1.TypedRoute.Get.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Get.is_datetime;\nconst $io1 = input => \"string\" === typeof input.id && $is_uuid(input.id) && \"string\" === typeof input.writer && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at));\nconst $io2 = input => \"number\" === typeof input.current && parseInt(input.current) === input.current && 0 <= input.current && (\"number\" === typeof input.limit && parseInt(input.limit) === input.limit && 0 <= input.limit) && (\"number\" === typeof input.records && parseInt(input.records) === input.records && 0 <= input.records) && (\"number\" === typeof input.pages && parseInt(input.pages) === input.pages && 0 <= input.pages);\nconst $so0 = input => `{\"data\":${`[${input.data.map(elem => $so1(elem)).join(\",\")}]`},\"pagination\":${$so2(input.pagination)}}`;\nconst $so1 = input => `{\"id\":${\"\\\"\" + input.id + \"\\\"\"},\"writer\":${$string(input.writer)},\"title\":${$string(input.title)},\"created_at\":${\"\\\"\" + input.created_at + \"\\\"\"}}`;\nconst $so2 = input => `{\"current\":${input.current},\"limit\":${input.limit},\"records\":${input.records},\"pages\":${input.pages}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); } }),\n__param(0, (0, core_1.TypedQuery)(input => {\nconst $number = core_1.TypedQuery.number;\nconst output = {\npage: $number(input.get(\"page\")),\nlimit: $number(input.get(\"limit\"))\n};\nreturn (input => {\nconst $guard = core_1.TypedQuery.guard;\nconst __is = input => {\nconst $io0 = input => (undefined === input.page || \"number\" === typeof input.page && !Number.isNaN(input.page) && parseInt(input.page) === input.page && 0 <= input.page) && (undefined === input.limit || \"number\" === typeof input.limit && !Number.isNaN(input.limit) && parseInt(input.limit) === input.limit && 0 <= input.limit);\nreturn \"object\" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (undefined === input.page || \"number\" === typeof input.page && !Number.isNaN(input.page) && (parseInt(input.page) === input.page || $guard(_exceptionable, {\npath: _path + \".page\",\nexpected: \"number (@type uint)\",\nvalue: input.page\n})) && (0 <= input.page || $guard(_exceptionable, {\npath: _path + \".page\",\nexpected: \"number (@type uint)\",\nvalue: input.page\n})) || $guard(_exceptionable, {\npath: _path + \".page\",\nexpected: \"(number | undefined)\",\nvalue: input.page\n})) && (undefined === input.limit || \"number\" === typeof input.limit && !Number.isNaN(input.limit) && (parseInt(input.limit) === input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type uint)\",\nvalue: input.limit\n})) && (0 <= input.limit || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"number (@type uint)\",\nvalue: input.limit\n})) || $guard(_exceptionable, {\npath: _path + \".limit\",\nexpected: \"(number | undefined)\",\nvalue: input.limit\n}));\nreturn (\"object\" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {\npath: _path + \"\",\nexpected: \"IPage.IRequest\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n})(output);\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"index\", null);\nBbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\nexports.BbsArticlesController = BbsArticlesController;\n\n\nJust call @TypedQuery() function on the query parameter, that's all.Nestia will analyze your type (IPage.IRequest), and writes optimal code for the target type, in the compilation level. If you click the \"Compiled JavaScript\" file tab of above and fine enhanced lines by blue lines, you can see the optimal parsing and validation code.Such optimization is called AOT (Ahead of Time) compilation, and it is the secret of @TypedQuery.","comment-tags#Comment Tags":"You can enhance validation logic, of @TypedQuery(), through comment tags.You know what? @TypedQuery() utilizes typia.assert<T>() function for query data validation, and the typia.assert<T>() function supports additional type checking logics through comment tags. For reference, the \"Comment Tag\" means a comment starting from @ symbol. It follows @${name} ${value} format, and you can add multiple comment tags per each property.With those comment tags, you can add additional validation logics. If you want to add a custom validation logic, you also can do it. Read below Guide Docments of typia, and see the example code. You may understand how to utilize such comment tags, in a few minutes.\ntypia > Validators > Comment Tags\nOutline\nSupported Tags\nCustomization\n\n\n\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = typia.createIs<CommentTag>();\n\ninterface CommentTag {\n/**\n* @type int\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\nimport typia from \"typia\";\n\nexport const checkCommentTag = (input) => {\nconst $is_datetime = typia.createIs.is_datetime;\nconst $is_uuid = typia.createIs.is_uuid;\nconst $io0 = (input) =>\n\"number\" === typeof input.type &&\nparseInt(input.type) === input.type &&\n(undefined === input.number ||\n(\"number\" === typeof input.number &&\n19 < input.number &&\n100 >= input.number)) &&\n\"string\" === typeof input.string &&\n3 <= input.string.length &&\n\"string\" === typeof input.pattern &&\nRegExp(/^[a-z]+$/).test(input.pattern) &&\n(null === input.format ||\n(\"string\" === typeof input.format && $is_datetime(input.format))) &&\nArray.isArray(input.array) &&\n3 <= input.array.length &&\n100 >= input.array.length &&\ninput.array.every((elem) => \"string\" === typeof elem && $is_uuid(elem));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};","restriction#Restriction":"When using @TypedQuery(), you've to follow such restrction.At first, type of @TypedQuery() must be a pure object type. It does not allow union type. Also, nullable and undefindable types are not allowed, either. Note that, query parameter type must be a sole object type without any extra definition.At next, type of properties must be atomic, or array of atomic type. In the atomic type case, the atomic type allows both nullable and undefindable types. However, mixed union atomic type like string | number or \"1\" | \"2\" | 3 are not allowed. Also, the array type does not allow both nullable and undefindable types, either.\nboolean\nnumber\nbigint\nstring\n\n\nexport interface SomeQueryDto {\n//----\n// ATOMIC TYPES\n//----\n// ALLOWED\nboolean: boolean;\nnumber: number;\nstring: string;\nbigint: bigint;\noptional_number?: number;\nnullable_string: string | null;\nliteral_union: \"A\" | \"B\" | \"C\" | \"D\";\n\n// NOT ALLOWED\nmixed_union: string | number | boolean;\nmixed_literal: \"A\" | \"B\" | 3;\n\n//----\n// ARRAY TYPES\n//----\n// ALLOWED\nnullable_element_array: (string | null)[];\nstring_array: string[];\nnumber_array: number[];\nliteral_union_array: (\"A\" | \"B\" | \"C\")[];\nliteral_tuple: [\"A\", \"B\", \"C\"];\n\n// NOT ALLOWED\noptional_element_array: (string | undefined)[];\noptional_array: string[] | undefined;\nnullable_array: string[] | null;\nunion_atomic_array: (string | number)[];\nmixed_literal_array: (\"A\", \"B\", 3)[];\nmixed_tuple: [\"A\", \"B\", 3];\n}"}},"/docs":{"title":"Index","data":{"":"","outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: super-fast decorators\n@nestia/sdk:\nSDK generator for clients\nSwagger generator evolved than ever\nAutomatic E2E test functions generator\n\n\nnestia: just CLI (command line interface) tool\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer\n\nSDK is similar with tRPC, but much advanced\n\n\nLeft is server code, and right is client (frontend) code","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/setup":{"title":"Setup","data":{"":"","boilerplate#Boilerplate":"npx nestia start <directory>\nJust run above npx nestia start <directory> command.Boilerplate would be automatically constructed in the <directory>.","setup-wizard#Setup Wizard":"npm install --save-dev nestia\nnpx nestia setup\nWhen you want to setup nestia in exiting project, just run above npx nestia setup command.Setup Wizard will install and configure everything automatically.","manual-setup#Manual Setup":"# COMPILERS\nnpm install --save-dev typescript\nnpm install --save-dev ts-node\nnpm install --save-dev ts-patch\n\n# NESTIA\nnpm install --save-dev nestia\nnpm install --save-dev @nestia/sdk\nnpm install --save @nestia/core\nIf you want to install nestia manually, you have to install ts-node and ts-patch modules as well as typescript. After installing those compilers, install nestia libraries like above.\n{\n\"strict\": true,\n\"strictNullChecks\": true,\n\"compilerOptions\": {\n\"plugins\": [\n{ \"transform\": \"@nestia/core/lib/transform\" },\n{ \"transform\": \"typia/lib/transform\" }\n]\n}\n}\nAfter that, configure tsconfig.json file like above.As @nestia/core and typia are generating optimal validation and JSON serialization code through transformation, you've to configure them as plugins.Also, never forget to configure strict (or strictNullChecks) as true. It is essential option for modern TypeScript development.\n{\n\"scripts\": {\n\"prepare\": \"ts-patch install\"\n}\n}\nAt last, configure npm run prepare command like above.Of course, you've to run the npm run prepare command after configuration.\n\n\n\nIf manual setup is difficult, just use the Setup Wizard."}},"/":{"title":"Index","data":{"":"","outline#Outline":"Nestia is a set of helper libraries for NestJS, supporting below features:\n@nestia/core: super-fast decorators\n@nestia/sdk:\nSDK generator for clients\nSwagger generator evolved than ever\nAutomatic E2E test functions generator\n\n\nnestia: just CLI (command line interface) tool\n\n\n\n\n\nOnly one line required, with pure TypeScript type\n\nRuntime validator is 20,000x faster than class-validator\n\nJSON serialization is 200x faster than class-transformer\n\nSDK is similar with tRPC, but much advanced","sponsors#Sponsors":"Thanks for your support.Your donation would encourage nestia development."}},"/docs/pure":{"title":"Pure TypeScript","data":{"":"","outline#Outline":"nestia can use pure TypeScript type.You know what? NestJS needs triple duplicated DTO schema definitions. The 1st is defining TypeScript type, the 2nd and 3rd are calling decorator functions of class-validator and @nestjs/swagger. It's not only annoying, but also error-prone. If you take any mistake on the 2nd or 3rd, it can't be detected by TypeScript compiler. It will be detected only at runtime. Another words, it is not type safe.Besides, nestia needs only pure TypeScript type. You don't need to define any extra schema like class-validator or @nestjs/swagger. Just define pure TypeScript type only (especially recommend to use interface type), then nestia will do all the rest.","demonstration#Demonstration":"If you're confusing how DTO of NestJS and nestia are different, just see example codes below.At first, look at the first (Triple duplicated NestJS DTO) tab, and find the BbsArticle.files property, enhanced by blue coloured blocks. Looking at the files property, how do you feel? Just defining an array object type, you've to call 7 decorator functions. If you take any mistake when using the decorator like omitting isArray property, it would be a critical runtime error.Besides, nestia needs only one line. Click the second (Pure Nestia DTO) tab, and find the IAttachmentFile.files property. Only one line being used, and IBbsArticle and IAttachment types are not even class, but just interface types. Comparing it to the first tab, how do you feel? Isn't it more simple and readable?This is the power of nestia, with pure TypeScript type.\n\n\nimport { ApiProperty } from \"@nestjs/swagger\";\nimport { ArrayNotEmpty, IsArray, IsObject, IsOptional, IsString, Match, MaxLength, Type, ValidateNested } from \"class-validator\";\n\nexport class BbsArticle {\n@ApiProperty({\nformat: \"uuid\",\n})\n@IsString()\nid!: string;\n\n// DUPLICATED SCHEMA DEFINITION\n// - duplicated function call + property type\n// - have to specify `isArray` and `nullable` props by yourself\n@ApiProperty({\ntype: () => AttachmentFile,\nnullable: true,\nisArray: true,\nminItems: 1,\ndescription: \"List of attached files.\",\n})\n@Type(() => AttachmentFile)\n@IsArray()\n@ArrayNotEmpty()\n@IsOptional()\n@IsObject({ each: true })\n@ValidateNested({ each: true })\nfiles!: AttachmentFile[] | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nminLength: 5,\nmaxLength: 100,\ndescription: \"Title of the article.\",\n})\n@IsOptional()\n@IsString()\ntitle!: string | null;\n\n@ApiProperty({\ndescription: \"Main content body of the article.\"\n})\n@IsString()\nbody!: string;\n\n@ApiProperty({\nformat: \"date-time\",\ndescription: \"Creation time of article\",\n})\n@IsString()\ncreated_at!: string;\n}\n\nexport class AttachmentFile {\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File name.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(255)\n@IsOptional()\n@IsString()\nname!: string | null;\n\n@ApiProperty({\ntype: \"string\",\nnullable: true,\nmaxLength: 255,\npattern: \"^[a-zA-Z0-9-_]+$\",\ndescription: \"File extension.\",\n})\n@Matches(/^[a-z0-9]+$/)\n@MaxLength(8)\n@IsOptional()\n@IsString()\nextension!: string | null;\n\n@ApiProperty({\nformat: \"url\",\ndescription: \"URL of the file.\",\n})\n@IsString()\nurl!: string;\n}\n\n\n\nexport interface IBbsArticle {\n/**\n* Primary Key.\n*\n* @format uuid\n*/\nid: string;\n\n/**\n* List of attached files.\n*\n* @minItems 1\n*/\nfiles: IAttachmentFile[] | null;\n\n/**\n* Title of the article.\n*\n* @minLength 5\n* @maxLength 100\n*/\ntitle: string | null;\n\n/**\n* Main content body of the article.\n*/\nbody: string;\n\n/**\n* Creation time of article.\n*\n* @format date-time\n*/\ncreated_at: string;\n}\n\nexport interface IAttachmentFile {\n/**\n* File name.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* File extension.\n*\n* @pattern ^[a-z0-9]+$\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* URL of the file.\n*\n* @format uri\n*/\nurl: string;\n}","aot-compilation#AOT Compilation":"Someone may be suspicious of the phrase \"Pure TypeScript Type\".\n\"As you know, TypeScript types do not have any tangible instance when compiled to JS.However, with only these fictitious TypeScript types, how can nestia validates types at runtime? How nestia builds swagger documents or SDK library with only these types? Are these things really possible without extra schema definition like class-validator or @nestjs/swagger?\"\nMy answer is: \"Yes, it is possible due to nestia analyzes your server code, and performs AOT compilation\".When compiling, nestia travels your NestJS server codes, and analyzes DTO definitions. And then, nestia writes optimal code to the compiled JavaScript file. In the @TypedBody() case, nestia transforms it to optimal validation code for the IBbsArticle.IStore type. Also, nestia transforms @TypedRoute.Post() function to optimal JSON serialization code for the IBbsArticle type.Such compile time optimization is called AOT (Ahead of Time) compilation. And this is the secret why nestia can do everything with only pure TypeScript type. Read below example codes, and just look how JavaScript file being compiled. Then you may understand why nestia is much easier, and futhermore much faster.\nRuntime validator is 20,000x faster than class-validator\nJSON serialization is 200x faster than class-transformer\n\n\n\n\nexport interface IBbsArticle extends IBbsArticle.IStore {\n/**\n* @format uuid\n*/\nid: string;\n\n/**\n* @format date-time\n*/\ncreated_at: string;\n}\nexport namespace IBbsArticle {\nexport interface IStore {\n/**\n* @minLength 3\n* @maxLength 50\n*/\ntitle: string;\nbody: string;\nfiles: IAttachmentFile[];\n}\n}\n\nexport interface IAttachmentFile {\n/**\n* @minLengt 1\n* @maxLength 255\n*/\nname: string | null;\n\n/**\n* @minLength 1\n* @maxLength 8\n*/\nextension: string | null;\n\n/**\n* @format url\n*/\nurl: string;\n}\n\n\n\nimport { TypedBody, TypedRoute } from \"@nestia/core\";\nimport { Controller } from \"@nestjs/common\";\n\nimport { IBbsArticle } from \"./IBbsArticle\";\n\n@Controller(\"bbs/articles\")\nexport class BbsArticlesController {\n@TypedRoute.Post() // 200x faster JSON serialization\npublic async store(\n// 20,000x faster validation\n@TypedBody() input: IBbsArticle.IStore\n): Promise<IBbsArticle> {\nreturn {\n...input,\nid: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\",\ncreated_at: \"2023-04-23T12:04:54.168Z\",\n}\n}\n}\n\n\n\n\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\nif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\nreturn function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\nfunction adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\nreturn new (P || (P = Promise))(function (resolve, reject) {\nfunction fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\nfunction rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\nfunction step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\nstep((generator = generator.apply(thisArg, _arguments || [])).next());\n});\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BbsArticlesController = void 0;\nconst core_1 = require(\"@nestia/core\");\nconst common_1 = require(\"@nestjs/common\");\nlet BbsArticlesController = class BbsArticlesController {\nstore(input) {\nreturn __awaiter(this, void 0, void 0, function* () {\nreturn Object.assign(Object.assign({}, input), { id: \"2b5e21d8-0e44-4482-bd3e-4540dee7f3d6\", created_at: \"2023-04-23T12:04:54.168Z\" });\n});\n}\n};\n__decorate([\ncore_1.TypedRoute.Post({ type: \"assert\", assert: input => { const assert = input => {\nconst __is = input => {\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io0 = input => \"string\" === typeof input.id && $is_uuid(input.id) && (\"string\" === typeof input.created_at && $is_datetime(input.created_at)) && (\"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length) && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.id && ($is_uuid(input.id) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string (@format uuid)\",\nvalue: input.id\n})) || $guard(_exceptionable, {\npath: _path + \".id\",\nexpected: \"string\",\nvalue: input.id\n})) && (\"string\" === typeof input.created_at && ($is_datetime(input.created_at) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string (@format datetime)\",\nvalue: input.created_at\n})) || $guard(_exceptionable, {\npath: _path + \".created_at\",\nexpected: \"string\",\nvalue: input.created_at\n})) && (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}; const stringify = input => {\nconst $string = core_1.TypedRoute.Post.string;\nconst $is_uuid = core_1.TypedRoute.Post.is_uuid;\nconst $is_datetime = core_1.TypedRoute.Post.is_datetime;\nconst $is_custom = core_1.TypedRoute.Post.is_custom;\nconst $is_url = core_1.TypedRoute.Post.is_url;\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nconst $so0 = input => `{\"id\":${\"\\\"\" + input.id + \"\\\"\"},\"created_at\":${\"\\\"\" + input.created_at + \"\\\"\"},\"title\":${$string(input.title)},\"body\":${$string(input.body)},\"files\":${`[${input.files.map(elem => $so1(elem)).join(\",\")}]`}}`;\nconst $so1 = input => `{\"name\":${null !== input.name ? $string(input.name) : \"null\"},\"extension\":${null !== input.extension ? $string(input.extension) : \"null\"},\"url\":${\"\\\"\" + input.url + \"\\\"\"}}`;\nreturn $so0(input);\n}; return stringify(assert(input)); }\n}),\n__param(0, (0, core_1.TypedBody)({\ntype: \"assert\",\nassert: input => {\nconst $guard = core_1.TypedBody.guard;\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst __is = input => {\nconst $is_custom = core_1.TypedBody.is_custom;\nconst $is_url = core_1.TypedBody.is_url;\nconst $io0 = input => \"string\" === typeof input.title && 3 <= input.title.length && 50 >= input.title.length && \"string\" === typeof input.body && (Array.isArray(input.files) && input.files.every(elem => \"object\" === typeof elem && null !== elem && $io1(elem)));\nconst $io1 = input => (null === input.name || \"string\" === typeof input.name && 255 >= input.name.length && $is_custom(\"minLengt\", \"string\", \"1\", input.name)) && (null === input.extension || \"string\" === typeof input.extension && 1 <= input.extension.length && 8 >= input.extension.length) && (\"string\" === typeof input.url && $is_url(input.url));\nreturn \"object\" === typeof input && null !== input && $io0(input);\n};\nif (false === __is(input))\n((input, _path, _exceptionable = true) => {\nconst $ao0 = (input, _path, _exceptionable = true) => (\"string\" === typeof input.title && (3 <= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@minLength 3)\",\nvalue: input.title\n})) && (50 >= input.title.length || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string (@maxLength 50)\",\nvalue: input.title\n})) || $guard(_exceptionable, {\npath: _path + \".title\",\nexpected: \"string\",\nvalue: input.title\n})) && (\"string\" === typeof input.body || $guard(_exceptionable, {\npath: _path + \".body\",\nexpected: \"string\",\nvalue: input.body\n})) && ((Array.isArray(input.files) || $guard(_exceptionable, {\npath: _path + \".files\",\nexpected: \"Array<IAttachmentFile>\",\nvalue: input.files\n})) && input.files.every((elem, _index1) => (\"object\" === typeof elem && null !== elem || $guard(_exceptionable, {\npath: _path + \".files[\" + _index1 + \"]\",\nexpected: \"IAttachmentFile\",\nvalue: elem\n})) && $ao1(elem, _path + \".files[\" + _index1 + \"]\", true && _exceptionable)));\nconst $ao1 = (input, _path, _exceptionable = true) => (null === input.name || \"string\" === typeof input.name && (255 >= input.name.length || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@maxLength 255)\",\nvalue: input.name\n})) && ($is_custom(\"minLengt\", \"string\", \"1\", input.name) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"string (@minLengt 1)\",\nvalue: input.name\n})) || $guard(_exceptionable, {\npath: _path + \".name\",\nexpected: \"(null | string)\",\nvalue: input.name\n})) && (null === input.extension || \"string\" === typeof input.extension && (1 <= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@minLength 1)\",\nvalue: input.extension\n})) && (8 >= input.extension.length || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"string (@maxLength 8)\",\nvalue: input.extension\n})) || $guard(_exceptionable, {\npath: _path + \".extension\",\nexpected: \"(null | string)\",\nvalue: input.extension\n})) && (\"string\" === typeof input.url && ($is_url(input.url) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string (@format url)\",\nvalue: input.url\n})) || $guard(_exceptionable, {\npath: _path + \".url\",\nexpected: \"string\",\nvalue: input.url\n}));\nreturn (\"object\" === typeof input && null !== input || $guard(true, {\npath: _path + \"\",\nexpected: \"IBbsArticle.IStore\",\nvalue: input\n})) && $ao0(input, _path + \"\", true);\n})(input, \"$input\", true);\nreturn input;\n}\n})),\n__metadata(\"design:type\", Function),\n__metadata(\"design:paramtypes\", [Object]),\n__metadata(\"design:returntype\", Promise)\n], BbsArticlesController.prototype, \"store\", null);\nBbsArticlesController = __decorate([\n(0, common_1.Controller)(\"bbs/articles\")\n], BbsArticlesController);\nexports.BbsArticlesController = BbsArticlesController;\n\n\n\nMeasured on Intel i5-1135g7, Surface Pro 8"}},"/docs/sdk/sdk":{"title":"SDK Library","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nnpx nestia sdk\n\n\nConfigure nestia.config.ts file and run npx nestia sdk command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate SDK (Software Development Kit) library. With the SDK library, you can easily develop e2e test program. Also, frontend developers can utilize the SDK library to interact with your NestJS backend server, much safely and conveniently.If you can't imagine how the SDK library works, then look at the gif image of below. Left side is the NestJS backend server program, and right side is the Frontend program interacting with your server. As you can see, frontend developer is utilizing auto completion through SDK library.Isn't it look like much more convenient and safer than before when using Swagger Documents?\n@nestia/sdk also can build Swagger Documents.Furthermore, @nestia/sdk is even much easier and powerful than @nestjs/swagger.","configuration#Configuration":"","nestiaconfigts#nestia.config.ts":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport type ts from \"typescript\";\n\nimport type { ISwaggerDocument } from \"./structures/ISwaggerDocument\";\nimport type { StripEnums } from \"./utils/StripEnums\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Compiler options for the TypeScript.\n*\n* If you've omitted this property or the assigned property cannot fully cover the\n* `tsconfig.json`, the properties from the `tsconfig.json` would be assigned to here.\n* Otherwise, this property has been configured and it's detailed values are different\n* with the `tsconfig.json`, this property values would be used instead.\n*\n* ```typescript\n* import ts from \"typescript\";\n*\n* const tsconfig: ts.TsConfig;\n* const nestiaConfig: IConfiguration;\n*\n* const compilerOptions: ts.CompilerOptions = {\n*     ...tsconfig.compilerOptions,\n*     ...(nestiaConfig.compilerOptions ?? {})\n* }\n* ```\n*/\ncompilerOptions?: StripEnums<ts.CompilerOptions>;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerDocument.IInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwaggerDocument.IServer[];\n\n/**\n* Security schemes.\n*/\nsecurity?: Record<string, ISwaggerConfig.ISecurityScheme>;\n}\nexport namespace ISwaggerConfig {\nexport type ISecurityScheme =\n| IApiKey\n| Exclude<\nISwaggerDocument.ISecurityScheme,\nISwaggerDocument.ISecurityScheme.IApiKey\n>;\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file. It must be placed on the top level directory of your NestJS backend project. Of course, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Path of controller files\noutput: Path of output directory for SDK library\n\nWhen you've completed above configuration, just run npx nestia sdk command. Then, SDK library would be newly generated, and placed into the $config.output directory following your nestia.config.ts option.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\noutput: \"src/api\",\n};\nexport default config;","manual-cli#Manual CLI":"npx nestia sdk <[source_directories_or_patterns]> \\\n--exclude <exclude_directory_or_pattern>\n--out <output_directory>\nInstead of configuring nestia.config.ts, you can use the CLI command instead.If your controller files are gathered into one directory, then write like below. About the output path, it must be a path of directory, not of file.\nnpx nestia swagger \"src/controllers\" --out \"./src/api\"\nnpx nestia swagger \"src/controllers\" --out \"./src/api\"\nOtherwise, your controller files are separated in multiple directories, you can choose two options. The 1st is listing up every directories of the controller directories, and the other is using regex pattern like below.\nnpx nestia swagger \\\n\"src/controllers\" \\\n\"src/appendix/controllers\" \\\n--out \"./src/api\"\nnpx nestia swagger \"src/**/*.controller.ts\" --out \"./src/api\"\nAlso, you can exclude some controller classes by specifying --exclude argument:\nnpx nestia swagger\n\"src/controllers\" \\\n--exclude \"src/**/*.fake.ts\" \\\n--out \"./dist/swagger.json\"","comment-tags#Comment Tags":"SDK library of @nestia/sdk supports special comment tags configuring client headers.\n@setHeader\n@assignHeaders\n\nAt first, @setHeader {accessor} configures only one header property. It reads special value of response body data with the accessor, and configures the special value to client header with last accessor key. In the below example case, key of authorization.token would be token, and key of authorization.timeout would be timeout.The other one @assignHeaders overwrites every property values to the client headers, with special instance of response body data with accessor. In the below example case, every properties in IShoppingCustomer.IActivated[\"authorization\"] would be assigned to the clinet headers.If you're confused, read example codes of below, clicking each tabs.\n\n\nimport { Controller } from \"@nestjs/common\";\n\n@Controller(\"shoppings/consumers/authenticate\")\nexport class ShoppingConsumerAuthenticateController {\n/**\n* @setHeader authorization.token token\n* @setHeader authorization.timeout timeout\n*/\n@TypedRoute.Post(\"join\")\npublic join(\n@TypedBody() input: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated>;\n\n/**\n* @assignHeaders authorization\n*/\n@TypedRoute.Post(\"login\")\npublic login(\n@TypedBody() inpu: IShoppingConsumer.ILogin\n): Promise<IShoppingConsumer.IActivated>;\n}\n\n\n\n/**\n* @packageDocumentation\n* @module api.functional.shoppings.consumers.authenticate\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\n//================================================================\nimport { Fetcher, Primitive } from \"@nestia/fetcher\";\nimport type { IConnection } from \"@nestia/fetcher\";\n\nimport type { IShoppingConsumer } from \"../../../../structures/IShoppingConsumer\";\n\nexport async function join(\nconnection: IConnection,\ninput: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated> {\nconst output: IShoppingConsumer.IActivated = await Fetcher.fetch(\nconnection,\njoin.ENCRYPTED,\njoin.METHOD,\njoin.path(),\ninput,\n);\n\n// configure header(s)\nconnection.headers ??= {};\nconnection.headers.token = output.authorization.token;\nconnection.headers.timeout = output.authorization.timeout;\n\nreturn output;\n}\nexport namespace join {\n...\n}\n\nexport async function login(\nconnection: IConnection,\ninput: IShoppingConsumer.IJoin\n): Promise<IShoppingConsumer.IActivated> {\nconst output: IShoppingConsumer.IActivated = await Fetcher.fetch(\nconnection,\nlogin.ENCRYPTED,\nlogin.METHOD,\nlogin.path(),\ninput,\n);\n\n// configure header(s)\nconnection.headers ??= {};\nObject.assign(connection.headers, output.authorization);\n\nreturn output;\n}\nexport namespace login {\n...\n}","distribution#Distribution":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\n};\nexport default config;\nThe best to way to distributing SDK library is just publishing as an NPM module.Configure distribute property of nestia.config.ts file, and run npx nestia sdk command. After that, distribution environments would be automatically composed with SDK library generation. At last, move to the packages/api directory, and run npm run deploy command for publishing.From now on, client developers can use the SDK library just by using npm install command.\ncd packages/api\nnpm run deploy\nOf course, before publishing the NPM module, you've to customize some configurations like package name. Initial name of the distribution envirionments is @ORGANIZATION/PROJECT-api, but you must change the package name of yours, isn't it?Also, if your SDK library utilize special alias paths, you also need to customize tsconfig.json file, too. Reading below example package.json and tsconfig.json files generated by nestia, consider which features to customize.\n\n\n{\n\"name\": \"@ORGANIZATION/PROJECT-api\",\n\"version\": \"0.1.0\",\n\"description\": \"SDK library generated by Nestia\",\n\"main\": \"lib/index.js\",\n\"typings\": \"lib/index.d.ts\",\n\"scripts\": {\n\"build\": \"npm run build:sdk && npm run compile\",\n\"build:sdk\": \"rimraf ../../src/api/functional && cd ../.. && npx nestia sdk && cd packages/api\",\n\"compile\": \"rimraf lib && tsc\",\n\"deploy\": \"npm run build && npm publish\"\n},\n\"repository\": {\n\"type\": \"git\",\n\"url\": \"https://github.com/samchon/nestia\"\n},\n\"author\": \"Jeongho Nam\",\n\"license\": \"MIT\",\n\"bugs\": {\n\"url\": \"https://github.com/samchon/nestia/issues\"\n},\n\"homepage\": \"https://nestia.io\",\n\"devDependencies\": {\n\"rimraf\": \"^5.0.0\",\n\"typescript\": \"^5.0.4\"\n},\n\"dependencies\": {\n\"@nestia/fetcher\": \"^1.2.0\"\n},\n\"files\": [\n\"lib\",\n\"package.json\",\n\"README.md\"\n]\n}\n\n\n\n{\n\"compilerOptions\": {\n\"target\": \"ES5\",\n\"lib\": [\n\"DOM\",\n\"ES2015\"\n],\n\"module\": \"commonjs\",\n\"declaration\": true,\n\"sourceMap\": true,\n\"outDir\": \"./lib\",\n\"downlevelIteration\": true,\n\"newLine\": \"lf\",\n\"esModuleInterop\": true,\n\"forceConsistentCasingInFileNames\": true,\n\"strict\": true,\n\"skipLibCheck\": true\n},\n\"include\": [\n\"../../src/api\"\n]\n}"}},"/docs/sdk/e2e":{"title":"E2e","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nnpx nestia e2e\n\n\nConfigure nestia.config.ts file and run npx nesta e2e command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate both SDK (Software Development Kit) library for client developers. Also, E2E test functions, utilizing the SDK library, will be automatically generated for correspnding to every API functions.Here is an example of generated E2E test functions:\nimport typia, { Primitive } from \"typia\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_body_store = async (\nconnection: api.IConnection\n): Promise<void> => {\nconst output: Primitive<IBbsArticle> =\nawait api.functional.body.store(\nconnection,\ntypia.random<Primitive<IBbsArticle.IStore>>(),\n);\ntypia.assert(output);\n};\n\nLeft is server code, and right is e2e test code utilizing SDK library","configuration#Configuration":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport type ts from \"typescript\";\n\nimport type { ISwaggerDocument } from \"./structures/ISwaggerDocument\";\nimport type { StripEnums } from \"./utils/StripEnums\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* Compiler options for the TypeScript.\n*\n* If you've omitted this property or the assigned property cannot fully cover the\n* `tsconfig.json`, the properties from the `tsconfig.json` would be assigned to here.\n* Otherwise, this property has been configured and it's detailed values are different\n* with the `tsconfig.json`, this property values would be used instead.\n*\n* ```typescript\n* import ts from \"typescript\";\n*\n* const tsconfig: ts.TsConfig;\n* const nestiaConfig: IConfiguration;\n*\n* const compilerOptions: ts.CompilerOptions = {\n*     ...tsconfig.compilerOptions,\n*     ...(nestiaConfig.compilerOptions ?? {})\n* }\n* ```\n*/\ncompilerOptions?: StripEnums<ts.CompilerOptions>;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerDocument.IInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwaggerDocument.IServer[];\n\n/**\n* Security schemes.\n*/\nsecurity?: Record<string, ISwaggerConfig.ISecurityScheme>;\n}\nexport namespace ISwaggerConfig {\nexport type ISecurityScheme =\n| IApiKey\n| Exclude<\nISwaggerDocument.ISecurityScheme,\nISwaggerDocument.ISecurityScheme.IApiKey\n>;\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia sdk command.At first, create nestia.config.ts file. It must be placed on the top level directory of your NestJS backend project. Of course, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those three properties:\ninput: Path of controller files\noutput: Path of output directory for SDK library\ne2e: Path of output directory for E2E test functions\n\nWhen you've completed above configuration, just run npx nestia e2e command. Then, SDK library would be generated into the $config.output directory, and E2E test functions would be generated into the $config.e2e directory, following your nestia.config.ts option.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\noutput: \"src/api\",\ndistribute: \"packages/api\",\ne2e: \"test\",\n};\nexport default config;","customization#Customization":"import core from \"@nestia/core\";\nimport { DynamicExecutor } from \"@nestia/e2e\";\n\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nasync function main(): Promise<void> {\nconst server: INestApplication = await NestFactory.create(\nawait core.DynamicModule.mount({\n// follows your nestia.config.ts setting\ncontrollers: {\ninput: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\n}),\n);\nawait server.listen(37_000);\n\nconst report: DynamicExecutor.IReport = await DynamicExecutor.validate({\nprefix: \"test\",\nparameters: () => [\n{\nhost: \"http://127.0.0.1:37000\",\n},\n],\n})(`${__dirname}/features`);\nawait server.close();\n\nconst exceptions: Error[] = report.executions\n.filter((exec) => exec.error !== null)\n.map((exec) => exec.error!);\nif (exceptions.length === 0) {\nconsole.log(\"Success\");\nconsole.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n} else {\nfor (const exp of exceptions) console.log(exp);\nconsole.log(\"Failed\");\nconsole.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\nprocess.exit(-1);\n}\n}\nmain().catch((exp) => {\nconsole.log(exp);\nprocess.exit(-1);\n});\nNothing be specified, customize by yourself.When you generate e2e test functions through npx nestia e2e command, such index.ts file would be placed into the top level directory of test program. As you can see, the initial e2e test program only opens your NestJS backend server only with path of controllers with port number 37,000.However, it may not fully meet your requirements. For example, you may connect to a database server, and also need to configure DI (Dependency Injection) classes, too. You've to configure those things by yourself. @nestia/sdk can analyzes your backend server in the compilation level, but unable to reproduce such customizations.\n\n\nimport { Controller } from \"@nestjs/common\";\nimport typia from \"typia\";\n\nimport core from \"@nestia/core\";\n\nimport { IBbsArticle } from \"@api/lib/structures/IBbsArticle\";\n\n@Controller(\"/bbs/articles/:section\")\nexport class BbsArticlesController {\n/**\n* Store a new article.\n*\n* @param section Section code\n* @param input Content to store\n* @returns Newly archived article\n*/\n@core.TypedRoute.Post()\npublic async store(\n@core.TypedParam(\"section\") section: string,\n@core.TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\nsection,\n...input,\n};\n}\n\n/**\n* Update an article.\n*\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*/\n@core.TypedRoute.Put(\":id\")\npublic async update(\n@core.TypedParam(\"section\") section: string,\n@core.TypedParam(\"id\", \"uuid\") id: string,\n@core.TypedBody() input: IBbsArticle.IStore,\n): Promise<IBbsArticle> {\nreturn {\n...typia.random<IBbsArticle>(),\nid,\nsection,\n...input,\n};\n}\n}\n\n\n\n/**\n* @packageDocumentation\n* @module api.functional.bbs.articles\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\n//================================================================\nimport { Fetcher, Primitive } from \"@nestia/fetcher\";\nimport type { IConnection } from \"@nestia/fetcher\";\n\nimport type { IBbsArticle } from \"./../../../structures/IBbsArticle\";\n\n/**\n* Store a new article.\n*\n* @param connection connection Information of the remote HTTP(s) server with headers (+encryption password)\n* @param section Section code\n* @param input Content to store\n* @returns Newly archived article\n*\n* @controller BbsArticlesController.store()\n* @path POST /bbs/articles/:section\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport function store\n(\nconnection: IConnection,\nsection: string,\ninput: Primitive<store.Input>\n): Promise<store.Output>\n{\nreturn Fetcher.fetch\n(\nconnection,\nstore.ENCRYPTED,\nstore.METHOD,\nstore.path(section),\ninput\n);\n}\nexport namespace store\n{\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METHOD = \"POST\" as const;\nexport const PATH: string = \"/bbs/articles/:section\";\nexport const ENCRYPTED: Fetcher.IEncrypted = {\nrequest: false,\nresponse: false,\n};\n\nexport function path(section: string): string\n{\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}`;\n}\n}\n\n/**\n* Update an article.\n*\n* @param connection connection Information of the remote HTTP(s) server with headers (+encryption password)\n* @param section Section code\n* @param id Target article ID\n* @param input Content to update\n* @returns Updated content\n*\n* @controller BbsArticlesController.update()\n* @path PUT /bbs/articles/:section/:id\n* @nestia Generated by Nestia - https://github.com/samchon/nestia\n*/\nexport function update\n(\nconnection: IConnection,\nsection: string,\nid: string,\ninput: Primitive<update.Input>\n): Promise<update.Output>\n{\nreturn Fetcher.fetch\n(\nconnection,\nupdate.ENCRYPTED,\nupdate.METHOD,\nupdate.path(section, id),\ninput\n);\n}\nexport namespace update\n{\nexport type Input = Primitive<IBbsArticle.IStore>;\nexport type Output = Primitive<IBbsArticle>;\n\nexport const METHOD = \"PUT\" as const;\nexport const PATH: string = \"/bbs/articles/:section/:id\";\nexport const ENCRYPTED: Fetcher.IEncrypted = {\nrequest: false,\nresponse: false,\n};\n\nexport function path(section: string, id: string): string\n{\nreturn `/bbs/articles/${encodeURIComponent(section ?? \"null\")}/${encodeURIComponent(id ?? \"null\")}`;\n}\n}\n\n\n\nimport typia, { Primitive } from \"typia\";\n\nimport api from \"../../../../src/api\";\nimport type { IBbsArticle } from \"../../../../src/api/structures/IBbsArticle\";\n\nexport const test_api_bbs_articles_update = async (\nconnection: api.IConnection,\n): Promise<void> => {\nconst output: Primitive<IBbsArticle> =\nawait api.functional.bbs.articles.update(\nconnection,\ntypia.random<Primitive<string>>(),\nuuid(),\ntypia.random<Primitive<IBbsArticle.IStore>>(),\n);\ntypia.assert(output);\n};\n\nconst uuid = (): string =>\n\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\nconst r = (Math.random() * 16) | 0;\nconst v = c === \"x\" ? r : (r & 0x3) | 0x8;\nreturn v.toString(16);\n});\n\n\nYou also need to customize each e2e test functions.When you run npx nestia e2e command, every e2e functions would be placed into $config.e2e/features/api/automated directory. Also, automatically generated e2e test functions are composing parameters through typia.random<T>() function.If your NestJS backend server development has not been completed, and your API functions are in the mock-up level, such random parameter composition would not be problem. Otherwise your API functions are enoughly completed, such random parameter composition may occur logic error.Therefore, you also need to customize automatically generated e2e test functions. Move each e2e test files from the $config.e2e/features/api/automated directory to somewhere else, and customize those e2e test functions to be suitable for your domain logics."}},"/docs/sdk/swagger":{"title":"Swagger Documents","data":{"":"","outline#Outline":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nnpx nestia swagger\n\n\nConfigure nestia.config.ts file and run npx nestia swagger command.Then, @nestia/sdk will analyze your NestJS backend server code, and generate swagger.json file.","configuration#Configuration":"","nestiaconfigts#nestia.config.ts":"import { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/controllers\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport type ts from \"typescript\";\n\nimport type { ISwaggerDocument } from \"./structures/ISwaggerDocument\";\nimport type { StripEnums } from \"./utils/StripEnums\";\n\n/**\n* Definition for the `nestia.config.ts` file.\n*\n* @author Jeongho Nam - https://github.com/samchon\n*/\nexport interface INestiaConfig {\n/**\n* Building `swagger.json` is also possible.\n*\n* If not specified, you can't build the `swagger.json`.\n*/\nswagger?: INestiaConfig.ISwaggerConfig;\n\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninput: string | string[] | INestiaConfig.IInput;\n\n/**\n* Output directory that SDK would be placed in.\n*\n* If not configured, you can't build the SDK library.\n*/\noutput?: string;\n\n/**\n* Target directory that SDK distribution files would be placed in.\n*\n* If you configure this property and runs `npx nestia sdk` command,\n* distribution environments for the SDK library would be generated.\n*\n* After the SDK library generation, move to the `distribute` directory,\n* and runs `npm publish` command, then you can share SDK library with\n* other client (frontend) developers.\n*\n* Recommend to use `\"packages/api\"` value.\n*/\ndistribute?: string;\n\n/**\n* Target directory that e2e test functions would be placed in.\n*\n* If you configure this property and runs `npx nestia e2e` command,\n* `@nestia/sdk` will analyze your NestJS backend server code, and\n* generates e2e test functions for every API endpoints.\n*\n* If not configured, you can't run `npx nestia e2e` command.\n*/\ne2e?: string;\n\n/**\n* Compiler options for the TypeScript.\n*\n* If you've omitted this property or the assigned property cannot fully cover the\n* `tsconfig.json`, the properties from the `tsconfig.json` would be assigned to here.\n* Otherwise, this property has been configured and it's detailed values are different\n* with the `tsconfig.json`, this property values would be used instead.\n*\n* ```typescript\n* import ts from \"typescript\";\n*\n* const tsconfig: ts.TsConfig;\n* const nestiaConfig: IConfiguration;\n*\n* const compilerOptions: ts.CompilerOptions = {\n*     ...tsconfig.compilerOptions,\n*     ...(nestiaConfig.compilerOptions ?? {})\n* }\n* ```\n*/\ncompilerOptions?: StripEnums<ts.CompilerOptions>;\n\n/**\n* Whether to assert parameter types or not.\n*\n* If you configure this property to be `true`, all of the function\n* parameters of SDK library would be checked through\n* [`typia.assert<T>()` function](https://typia.io/docs/validators/assert/).\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enahcne the type safety even in the runtime level.\n*\n* @default false\n*/\nassert?: boolean;\n\n/**\n* Whether to optimize JSON string conversion 10x faster or not.\n*\n* If you configure this property to be `true`, the SDK library would utilize the\n* [`typia.assertStringify<T>() function`](https://github.com/samchon/typia#enhanced-json)\n* to boost up JSON serialization speed and ensure type safety.\n*\n* This option would make your SDK library compilation time a little bit slower,\n* but would enhance JSON serialization speed 10x faster. Also, it can ensure type\n* safety even in the rumtime level.\n*\n* @default false\n*/\njson?: boolean;\n\n/**\n* Whether to wrap DTO by primitive type.\n*\n* If you don't configure this property as `false`, all of DTOs in the\n* SDK library would be automatically wrapped by {@link Primitive} type.\n*\n* For refenrece, if a DTO type be capsuled by the {@link Primitive} type,\n* all of methods in the DTO type would be automatically erased. Also, if\n* the DTO has a `toJSON()` method, the DTO type would be automatically\n* converted to return type of the `toJSON()` method.\n*\n* @default true\n*/\nprimitive?: boolean;\n}\nexport namespace INestiaConfig {\n/**\n* List of files or directories to include or exclude to specifying the NestJS\n* controllers.\n*/\nexport interface IInput {\n/**\n* List of files or directories containing the NestJS controller classes.\n*/\ninclude: string[];\n\n/**\n* List of files or directories to be excluded.\n*/\nexclude?: string[];\n}\n\n/**\n* Building `swagger.json` is also possible.\n*/\nexport interface ISwaggerConfig {\n/**\n* Output path of the `swagger.json`.\n*\n* If you've configured only directory, the file name would be the `swagger.json`.\n* Otherwise you've configured the full path with file name and extension, the\n* `swagger.json` file would be renamed to it.\n*/\noutput: string;\n\n/**\n* API information.\n*\n* If omitted, `package.json` content would be used instead.\n*/\ninfo?: Partial<ISwaggerDocument.IInfo>;\n\n/**\n* List of server addresses.\n*/\nservers?: ISwaggerDocument.IServer[];\n\n/**\n* Security schemes.\n*/\nsecurity?: Record<string, ISwaggerConfig.ISecurityScheme>;\n}\nexport namespace ISwaggerConfig {\nexport type ISecurityScheme =\n| IApiKey\n| Exclude<\nISwaggerDocument.ISecurityScheme,\nISwaggerDocument.ISecurityScheme.IApiKey\n>;\nexport interface IApiKey {\ntype: \"apiKey\";\n\n/**\n* @default header\n*/\nin?: \"header\" | \"query\" | \"cookie\";\n\n/**\n* @default Authorization\n*/\nname?: string;\n}\n}\n}\n\n\nMake nestia.config.ts file and run npx nestia swagger command.At first, create nestia.config.ts file. It must be placed on the top level directory of your NestJS backend project. Of course, tsconfig.json file also must be placed in the top level directory, too. After creation, configure the nestia.config.ts file referencing above example code and type definition.At least, you've to configure those two properties:\ninput: Path of controller files\nswagger.output: Path of swagger.json file\n\nWhen you've completed above configuration, just run npx nestia swagger command. Then, swagger.json file would be newly generated, and placed into the $config.swagger.output directory following your nestia.config.ts option.By the way, if your controller files are separated into multiple directories, you can choose two options. First is listing up every directories, and second is using regex expression. Also, you can exclude some special directories or files using exclude option. Of course, you can mix all of these options like below:\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: [\n\"src/controllers\",\n\"src/fake/controllers\",\n\"src/test/controllers\",\n],\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: \"src/**/*.controller.ts\",\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;\n\n\n\nimport { INestiaConfig } from \"@nestia/sdk\";\n\nconst config: INestiaConfig = {\ninput: {\ninclude: [\"src/controllers\"],\nexclude: [\"src/**/*.fake.ts\"],\n},\nswagger: {\noutput: \"dist/swagger.json\",\nsecurity: {\nbearer: {\ntype: \"apiKey\",\nname: \"Authorization\",\nin: \"header\",\n},\n},\nservers: [\n{\nurl: \"http://localhost:3000\",\ndescription: \"Local Server\"\n}\n],\n}\n};\nexport default config;","manual-cli#Manual CLI":"npx nestia swagger <[source_directories_or_patterns]> \\\n--exclude <exclude_directory_or_pattern> \\\n--out <output_path>\nInstead of configuring nestia.config.ts, you can use the CLI command instead.If your controller files are gathered into one directory, then write like below. About the output path, it does not matter whether directory or file name. Of course, if you write only directory name, then file name of the Swagger Documents would be swagger.json as default.\nnpx nestia swagger \"src/controllers\" --out \"./dist\"\nnpx nestia swagger \"src/controllers\" --out \"./dist/swagger.json\"\nOtherwise, your controller files are separated in multiple directories, you can choose two options. The 1st is listing up every directories of the controller directories, and the other is using regex pattern like below.\nnpx nestia swagger \"src/controllers\" \"src/appendix/controllers\" --out \"./dist/swagger.json\"\nnpx nestia swagger \"src/**/*.controller.ts\" --out \"./dist\"\nAlso, you can exclude some controller classes by specifying --exclude argument:\nnpx nestia swagger\n\"src/controllers\" \\\n--exclude \"src/**/*.fake.ts\" \\\n--out \"./dist/swagger.json\"","comment-tags#Comment Tags":"","controller-methods#Controller Methods":"Swagger generator @nestia/sdk supports three comment tags for controller methods:\n@deprecated: mark as deprecated\n@internal: hide, never be shown\n@tag {name}: grouppig\n\nAt first, @internal tag is used to hide the controller method from the Swagger Documents. When you use it, the controller method would not be written in the swagger.json file. Otherwise, the @deprecated tag is used to mark the controller method as deprecated. When you use it, Swagger Editor will show the deprecated message about the route method like below.At last, @tag {name} tag is used for groupping.\n@Controller(\"some\")\nexport class SomeController {\n/**\n* Would be shown without any mark.\n*\n* @tag public\n*/\n@Get(\"public\")\npublic public(): void {}\n\n/**\n* Would be marked as \"deprecated\"\n*\n* @tag public\n*/\n@Get(\"deprecated\")\npublic deprepcated(): void {}\n\n/**\n* Would not be shown.\n*\n* @internal\n*/\n@Get(\"internal\")\npublic internal(): void {}\n}","dto-properties#DTO Properties":"https://swagger.io/docs/specification/data-models/data-types/You can utilize comments and comment tags to construct special fields of JSON schema.If you write any comment on a property, it would fill the IJsonSchema.description value. When you write some comment tags starting with @ symbol, they would be placed into the proper properties of IJsonSchema. Below is the list of supported comment tags in the @nestia/sdk.Also, such comment tags of DTO properties can be used to enhance validation logic of @nestia/core library. Especially, @TypedBody.${method}(), @TypedRoute() and @TypedQuery() functions can use same comment tags for additional validation.Let's see how those comment tags work with example code.\ncommon\n@deprecated\n@title {string}\n@default {value}\n\n\nnumber\n@type {\"int\"|\"uint\"}\n@minimum {number}\n@maximum {number}\n@exclusiveMinimum {number}\n@exclusiveMaximum {number}\n@multipleOf {number}\n\n\nstring\n@minLength {number}\n@maxLength {number}\n@pattern {regex}\n@format {keyword}\nemail\nuuid\nipv4\nipv6\ndate: YYYY-MM-DD\ndate-time: Date.toISOString()\n\n\narray\n@minItems {number}\n@maxItems {number}\n\n\n\n\n\n\nexport interface CommentTag {\n/**\n* @title Unsigned integer\n* @type uint\n* @deprecated\n*/\ntype: number;\n\n/**\n* @exclusiveMinimum 19\n* @maximum 100\n* @default 30\n*/\nnumber?: number;\n\n/**\n* @minLength 3\n*/\nstring: string;\n\n/**\n* @pattern ^[a-z]+$\n*/\npattern: string;\n\n/**\n* @format date-time\n*/\nformat: string | null;\n\n/**\n* In the Array case, possible to restrict its elements.\n*\n* @minItems 3\n* @maxItems 100\n* @format uuid\n*/\narray: string[];\n}\n\n\n\n\"CommentTag\": {\n\"$id\": \"components#/schemas/CommentTag\",\n\"type\": \"object\",\n\"properties\": {\n\"type\": {\n\"type\": \"integer\",\n\"nullable\": false,\n\"deprecated\": true,\n\"title\": \"Unsigned integer\",\n\"minimum\": 0,\n},\n\"number\": {\n\"type\": \"number\",\n\"nullable\": false,\n\"minimum\": 19,\n\"exclusiveMinimum\": true,\n\"maximum\": 100,\n\"default\": 30,\n},\n\"string\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"minLength\": 3,\n},\n\"pattern\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"pattern\": \"^[a-z]+$\",\n},\n\"format\": {\n\"type\": \"string\",\n\"nullable\": true,\n\"format\": \"date-time\",\n},\n\"array\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"string\",\n\"nullable\": false,\n\"description\":\n\"In the Array case, possible to restrict its elements.\",\n\"format\": \"uuid\",\n},\n\"nullable\": false,\n\"description\":\n\"In the Array case, possible to restrict its elements.\",\n\"minItems\": 3,\n\"maxItems\": 100,\n},\n},\n\"nullable\": false,\n\"required\": [\n\"type\",\n\"string\",\n\"pattern\",\n\"format\",\n\"array\",\n]\n}","distribution#Distribution":"You can choose two options for swagger.json file distribution.The 1st is publishing the swagger.json file in a public repo, and showing it through Swagger Editor like below:\nsamchon/nestia-template: Swagger Editor\nsamchon/fake-iamport-server: Swagger Editor\nsamchon/fake-toss-payments-server: Swagger Editor\n\nThe 2nd way is to hosting the swagger.json file in the NestJS backend server.Read below example code, and follow it on yours:\nimport fs from \"fs\";\nimport { NestFactory } from '@nestjs/core';\nimport { SwaggerModule } from '@nestjs/swagger';\n\nasync function open(): Promise<void> {\nconst app = await NestFactory.create(...);\n\nconst docs = require(\"...write swagger.json path\");\ndocs.servers = [\n{ url: \"write your server URL\" }\n];\nSwaggerModule.setup(\"swagger\", app, docs);\n\nawait app.listen(8080);\n}"}}}